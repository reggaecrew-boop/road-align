<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>道路線形計算（iPadオフラインPWA）</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#2563eb">
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js");
    }
  </script>

  <style>
    :root{
      --bg:#f2f6ff; --card:#fff; --text:#0f172a; --muted:#64748b; --line:#e2e8f0;
      --accent:#2563eb; --ok:#16a34a; --warn:#b45309;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Hiragino Sans", "Noto Sans JP", "Segoe UI", sans-serif;
      background:linear-gradient(135deg,#eff6ff,#eef2ff);
      color:var(--text);
    }
    .wrap{ max-width:1180px; margin:0 auto; padding:16px; }
    .header{
      background:var(--card); border:1px solid var(--line); border-radius:14px;
      padding:16px; box-shadow:0 10px 25px rgba(0,0,0,.06);
      position: sticky; top: 0; z-index: 10;
      backdrop-filter: blur(6px);
    }
    .title{ display:flex; gap:10px; align-items:center; font-weight:900; font-size:20px; flex-wrap:wrap; }
    .badge{ font-size:12px; color:var(--muted); border:1px solid var(--line); padding:2px 8px; border-radius:999px; }
    .grid{ display:grid; gap:10px; }
    .grid-2{ grid-template-columns:1fr 1fr; }
    .grid-3{ grid-template-columns:1fr 1fr 1fr; }
    .grid-4{ grid-template-columns:1fr 1fr 1fr 1fr; }
    @media (max-width:900px){ .grid-2,.grid-3,.grid-4{ grid-template-columns:1fr; } }
    .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:end; margin-top:12px; }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }
    input, select, button, textarea{
      width:100%; padding:10px 10px; border:1px solid var(--line); border-radius:10px;
      background:#fff; font-size:14px;
    }
    input[type="number"]{ font-variant-numeric: tabular-nums; }
    textarea{ min-height:88px; resize:vertical; }
    .card{
      margin-top:14px; background:var(--card); border:1px solid var(--line); border-radius:14px;
      padding:14px; box-shadow:0 10px 25px rgba(0,0,0,.05);
    }
    .card h2{ margin:0 0 10px; font-size:16px; }
    .btn{
      border:0; border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer;
      background:var(--accent); color:#fff;
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn-ghost{ background:#fff; color:var(--text); border:1px solid var(--line); }
    .btn-ok{ background:var(--ok); }
    .mini{ font-size:12px; color:var(--muted); }
    .warn{ color:var(--warn); font-size:13px; margin-top:6px; }
    table{ width:100%; border-collapse:collapse; overflow:auto; }
    th,td{ border:1px solid var(--line); padding:8px; font-size:13px; }
    th{ background:#f1f5f9; text-align:left; }
    .right{ text-align:right; }
    .pill{
      display:inline-block; padding:3px 8px; border-radius:999px; border:1px solid var(--line);
      font-size:12px; color:var(--muted);
    }
    .tabs{ display:flex; gap:8px; margin-top:12px; }
    .tab{
      flex:1; padding:10px; border-radius:12px; border:1px solid var(--line); background:#fff;
      font-weight:900; cursor:pointer;
    }
    .kpi{ font-weight:900; color:var(--accent); }
    .canvasWrap{ width:100%; overflow:auto; }
    canvas{ border:1px solid var(--line); border-radius:12px; background:#fff; }
    .footer{ margin-top:16px; text-align:center; color:var(--muted); font-size:12px; }
    .sep{ height:1px; background:var(--line); margin:10px 0; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="header">
    <div class="title">
      道路線形計算（iPadオフラインPWA）
      <span class="badge">同一ページ：平面 → 縦断 → 出力 → 保存 / 自動保存（localStorage）</span>
    </div>

    <div class="row">
      <div style="flex:1; min-width:220px;">
        <label>案件名</label>
        <input id="projectName" type="text" />
      </div>

      <div style="width:170px;">
        <label>座標小数桁（N/E）</label>
        <select id="coordDecimals">
          <option value="3">小数3桁</option>
          <option value="4">小数4桁</option>
        </select>
      </div>

      <div style="width:160px;">
        <label>測点表示ピッチ（整数m）</label>
        <input id="staPitch" type="number" step="1" min="1" />
      </div>

      <div style="width:160px;">
        <label>出力間隔（整数m）</label>
        <input id="outputStep" type="number" step="1" min="1" />
      </div>

      <div style="width:160px;">
        <label>クロソイド ds(m)</label>
        <input id="dsSpiral" type="number" step="0.1" />
      </div>

      <div style="width:170px;">
        <label>クロソイド指定</label>
        <select id="clothoidMode">
          <option value="A">A値（A1/A2）</option>
          <option value="L">Ls（長さ）</option>
        </select>
      </div>
    </div>

    <div class="tabs">
      <button class="tab" data-jump="secPlan">平面</button>
      <button class="tab" data-jump="secProfile">縦断</button>
      <button class="tab" data-jump="secCross">横断</button>
      <button class="tab" data-jump="secOutput">出力</button>
      <button class="tab" data-jump="secSave">保存</button>
    </div>
  </div>

  <div id="viewPlan"></div>
  <div id="viewProfile"></div>
  <div id="viewCross"></div>
  <div id="viewOutput"></div>
  <div id="viewSave"></div>

  <div class="footer">ホーム画面に追加して使う前提（PWA）。まずは一度オンラインで開いてキャッシュしてね。</div>
</div>

<script>
/* =========================
   State + autosave (iPad)
========================= */
const LS_KEY_NEW = "road_align_pwa_state_v3_unified";
const LS_KEY_OLD = "road_align_pwa_state_v2_profile";
const LS_KEY = LS_KEY_NEW;

let state = {
  projectName: "テスト案件",
  coordDecimals: 3,
  staPitch: 20,
  outputStep: 20,
  dsSpiral: 0.5,
  clothoidMode: "A",

  bp: { name: "BP", N: 0, E: 0 },
  ep: { name: "EP", N: 0, E: 500 },

  ipPoints: [
    { id: 1, name: "IP1", N: 0, E: 0 },
    { id: 2, name: "IP2", N: 0, E: 200 },
    { id: 3, name: "IP3", N: 150, E: 350 },
  ],
  useIpCount: 3,

  curveSettings: [
    { id: 1, ipName: "IP2", R: 200, A1: 100, A2: 100, Ls: 40, direction: "auto" }
  ],

  // 追加測点（タブ別）
  extraStations: {
    plan: [],
    profile: [],
    cross: [],
    output: [],
  },
  nextExtraId: {
    plan: 1,
    profile: 1,
    cross: 1,
    output: 1,
  },

  plotStep: 5.0,
  showKeypoints: true,
  showArrow: false,

  // ===== 縦断（勾配区間 + 縦断曲線(VPI単位)） =====
  profile: {
    enabled: true,
    startSta: 0.000,
    startZ: 0.000,
    grades: [
      { id: 1, nextSta: 100.000, gradePct:  2.534 },
      { id: 2, nextSta: 300.000, gradePct: -1.000 },
      { id: 3, nextSta: 500.000, gradePct:  0.500 }
    ],
    nextGradeId: 4,

    // VPIごと（PVの中間点）に縦断曲線を紐付け
    // L優先。Lが空なら ymax から L=8*ymax/|A| に換算
    vcurves: [
      { id: 1, vpiSta: 100.000, L: 80.000, ymax: null },
      { id: 2, vpiSta: 300.000, L: null,   ymax: 0.145 }
    ],
    nextVcurveId: 3,
  },

  // ===== 横断（中心からの勾配区間） =====
  // 共通（全測点）テンプレ + 測点別の例外（必要な測点だけ）
  cross: {
    enabled: true,


    // 拡幅割付（テーパ）：例外測点（最外端距離）を制御点にして線形補間
    taper: { enabled: true, anchorRight: 3.000, anchorLeft: 3.000 },

    // ---- 共通（全測点） ----
    // 中心(0.000m, Z=0.000m) から外側へ。end は中心からの距離(m)。
    // 勾配(%)は「外側へ進むほど Z が上がる：+ / 下がる：-」で入力。
    right: {
      segs: [
        { id: 1, end: 3.000, slopePct: -2.000 },
        { id: 2, end: 4.500, slopePct:  0.000 },
        { id: 3, end: 5.000, slopePct: -1.000 },
      ],
      nextSegId: 4
    },
    left: {
      segs: [
        { id: 1, end: 3.000, slopePct: -2.000 },
        { id: 2, end: 4.500, slopePct:  0.000 },
        { id: 3, end: 5.000, slopePct: -1.000 },
      ],
      nextSegId: 4
    },

    // ---- 測点別（例外） ----
    // key: "100.000" のように 0.001m丸めの測点文字列
    // value: { right:{segs,nextSegId}, left:{...} }
    overrides: {},

    // UI状態（選択中の例外測点 / プレビュー測点）
    ui: { selectedStaKey: "", previewTok: "" }
  }


};

function saveState() {
  try { localStorage.setItem(LS_KEY, JSON.stringify(state)); } catch(e) {}
}
function normalizeState(s) {
  // --- extraStations ---
  if (Array.isArray(s.extraStations)) {
    // 旧: extraStations:[] / nextExtraId:number を output に移す
    const old = s.extraStations;
    const oldNext = Number.isFinite(s.nextExtraId)
      ? s.nextExtraId
      : (Math.max(0, ...old.map(r => r.id || 0)) + 1);
    s.extraStations = { plan: [], profile: [], cross: [], output: old };
    s.nextExtraId = { plan: 1, profile: 1, cross: 1, output: oldNext };
  } else {
    s.extraStations = Object.assign({ plan: [], profile: [], cross: [], output: [] }, s.extraStations || {});
    for (const k of ["plan", "profile", "cross", "output"]) {
      if (!Array.isArray(s.extraStations[k])) s.extraStations[k] = [];
    }
    if (!s.nextExtraId || typeof s.nextExtraId !== "object" || Array.isArray(s.nextExtraId)) {
      s.nextExtraId = { plan: 1, profile: 1, cross: 1, output: 1 };
    }
    s.nextExtraId = Object.assign({ plan: 1, profile: 1, cross: 1, output: 1 }, s.nextExtraId);
  }

  // --- profile ---
  s.profile = Object.assign({
    enabled: true,
    startSta: 0,
    startZ: 0,
    grades: [],
    nextGradeId: 1,
    vcurves: [],
    nextVcurveId: 1,
  }, s.profile || {});

  // 旧: rows/nextRowId -> grades/vcurves
  if (Array.isArray(s.profile.rows)) {
    const rows = (s.profile.rows || [])
      .filter(r => Number.isFinite(r.nextSta) && Number.isFinite(r.gradePct))
      .slice()
      .sort((a, b) => Number(a.nextSta) - Number(b.nextSta));

    s.profile.grades = rows.map((r, idx) => ({
      id: Number.isFinite(r.id) ? r.id : (idx + 1),
      nextSta: Number(r.nextSta) || 0,
      gradePct: Number(r.gradePct) || 0,
    }));

    s.profile.nextGradeId = Number.isFinite(s.profile.nextRowId)
      ? s.profile.nextRowId
      : (Math.max(0, ...s.profile.grades.map(r => r.id || 0)) + 1);

    const vc = [];
    for (let i = 0; i < rows.length - 1; i++) {
      const r = rows[i];
      const L = (r.vcL == null || r.vcL === "") ? null : Number(r.vcL);
      const ymax = (r.vcYmax == null || r.vcYmax === "") ? null : Number(r.vcYmax);
      const hasL = Number.isFinite(L) && L > 0;
      const hasY = Number.isFinite(ymax) && ymax > 0;
      if (!hasL && !hasY) continue;
      vc.push({
        id: vc.length + 1,
        vpiSta: Number(r.nextSta) || 0,
        L: hasL ? L : null,
        ymax: hasY ? ymax : null,
      });
    }
    s.profile.vcurves = vc;
    s.profile.nextVcurveId = vc.length + 1;

    delete s.profile.rows;
    delete s.profile.nextRowId;
  }

  s.profile.grades = Array.isArray(s.profile.grades) ? s.profile.grades : [];
  s.profile.vcurves = Array.isArray(s.profile.vcurves) ? s.profile.vcurves : [];

  s.profile.nextGradeId = Number.isFinite(s.profile.nextGradeId)
    ? s.profile.nextGradeId
    : (Math.max(0, ...s.profile.grades.map(r => r.id || 0)) + 1);

  s.profile.nextVcurveId = Number.isFinite(s.profile.nextVcurveId)
    ? s.profile.nextVcurveId
    : (Math.max(0, ...s.profile.vcurves.map(r => r.id || 0)) + 1);

  
  // --- cross ---
  s.cross = Object.assign({
    enabled: true,
    taper: { enabled: true, anchorRight: 3.000, anchorLeft: 3.000 },
    right: { segs: [], nextSegId: 1 },
    left:  { segs: [], nextSegId: 1 },
    overrides: {},
    ui: { selectedStaKey: "", previewTok: "" },
  }, s.cross || {});

  if (!s.cross.overrides || typeof s.cross.overrides !== "object" || Array.isArray(s.cross.overrides)) {
    s.cross.overrides = {};
  }
  if (!s.cross.ui || typeof s.cross.ui !== "object" || Array.isArray(s.cross.ui)) {
    s.cross.ui = { selectedStaKey: "", previewTok: "" };
  }
  if (typeof s.cross.ui.selectedStaKey !== "string") s.cross.ui.selectedStaKey = "";
  if (typeof s.cross.ui.previewTok !== "string") s.cross.ui.previewTok = "";

  const normSide = (obj)=>{
    obj = (obj && typeof obj === "object" && !Array.isArray(obj)) ? obj : {};
    let segs = Array.isArray(obj.segs) ? obj.segs : [];
    segs = segs.map((r, idx)=>({
      id: (r && Number.isFinite(r.id)) ? r.id : (idx + 1),
      end: Number(r && r.end),
      slopePct: Number.isFinite(Number(r && r.slopePct)) ? Number(r.slopePct) : 0,
    })).filter(r => Number.isFinite(r.end) && r.end > 0);

    segs.sort((a,b)=>a.end-b.end);

    let nextSegId = obj.nextSegId;
    if (!Number.isFinite(nextSegId)) {
      const mx = Math.max(0, ...segs.map(r => r.id || 0));
      nextSegId = mx + 1;
    }
    return { segs, nextSegId };
  };

  s.cross.right = normSide(s.cross.right);
  s.cross.left  = normSide(s.cross.left);

  const newOver = {};
  for (const [k, ov] of Object.entries(s.cross.overrides || {})) {
    const m = parseFloat(k);
    if (!Number.isFinite(m)) continue;
    const key = m.toFixed(3);
    if (!ov || typeof ov !== "object" || Array.isArray(ov)) continue;
    newOver[key] = {
      right: normSide(ov.right),
      left:  normSide(ov.left),
    };
  }
  s.cross.overrides = newOver;

  if (s.cross.ui.selectedStaKey && !s.cross.overrides[s.cross.ui.selectedStaKey]) {
    s.cross.ui.selectedStaKey = "";
  }


  return s;
}

function loadState() {
  const tNew = localStorage.getItem(LS_KEY_NEW);
  const tOld = localStorage.getItem(LS_KEY_OLD);
  const t = tNew || tOld;
  if (!t) return;
  try {
    const obj = JSON.parse(t);
    if (obj && typeof obj === "object") {
      state = Object.assign(state, obj);
      state = normalizeState(state);

      // 旧キーから読み込んだ場合は新キーにも書き戻す
      if (!tNew && tOld) {
        try { localStorage.setItem(LS_KEY_NEW, JSON.stringify(state)); } catch (e) {}
      }
    }
  } catch (e) {}
}
loadState();

/* =========================
   Math / utilities
========================= */
const clamp = (x, min, max) => Math.max(min, Math.min(max, x));
const norm = (x, y) => Math.sqrt(x * x + y * y);
const unit = (x, y) => {
  const len = norm(x, y);
  return len === 0 ? [1, 0] : [x / len, y / len];
};
const dot = (ax, ay, bx, by) => ax * bx + ay * by;
const crossZ = (ax, ay, bx, by) => ax * by - ay * bx;
const wrap360 = (deg) => ((deg % 360) + 360) % 360;

const azFromVec = (dE, dN) => wrap360((Math.atan2(dE, dN) * 180) / Math.PI);
const psiFromAz = (azDeg) => (Math.PI / 2) - (azDeg * Math.PI / 180);
const azFromPsi = (psi) => wrap360(((Math.PI / 2 - psi) * 180) / Math.PI);

const dedupeConsecutivePoints = (pts, eps = 1e-9) => {
  const out = [];
  for (const p of pts) {
    if (!out.length) { out.push(p); continue; }
    const q = out[out.length - 1];
    if (Math.hypot(p.E - q.E, p.N - q.N) > eps) out.push(p);
  }
  return out;
};

const dedupeSorted = (arr, eps = 1e-7) => {
  const out = [];
  for (const v of arr) {
    if (!out.length || Math.abs(v - out[out.length - 1]) > eps) out.push(v);
  }
  return out;
};

const csvEscape = (v) => {
  const s = String(v ?? "");
  return /[,"\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
};

const downloadText = (text, filename, mime="text/plain;charset=utf-8") => {
  const blob = new Blob([text], { type: mime });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
};

const downloadCSV = (rows, filename) => {
  if (!rows?.length) return;
  const headers = Object.keys(rows[0]);
  const body = rows.map(r => headers.map(h => csvEscape(r[h])).join(","));
  const csv = [headers.join(","), ...body].join("\n");
  const blob = new Blob(["\ufeff" + csv], { type: "text/csv;charset=utf-8;" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
};

/* ---- 測点（ピッチ表示） ---- */
const metersToStaPitch = (m, pitch, d=3) => {
  pitch = Math.max(1, Math.floor(pitch || 1));
  if (!Number.isFinite(m)) return "-";
  if (m < 0) return m.toFixed(d);
  const k = Math.floor(m / pitch);
  const rem = m - k * pitch;
  return `${k}+${rem.toFixed(d)}`;
};

const parseTokenToM = (token, pitch) => {
  pitch = Math.max(1, Math.floor(pitch || 1));
  let s = String(token ?? "").trim();
  if (!s) throw new Error("空です");
  s = s.replace(/[mMｍＭ]\s*$/, "").trim();
  if (s.includes("+")) {
    const [a, b] = s.split("+", 2);
    const k = parseFloat(a.trim());
    const rem = parseFloat(b.trim());
    if (!Number.isFinite(k) || !Number.isFinite(rem)) throw new Error("測点の数値が不正");
    return k * pitch + rem;
  }
  const mv = parseFloat(s);
  if (!Number.isFinite(mv)) throw new Error("数値が不正");
  return mv;
};

const setOrNull = (v)=> {
  const t = String(v ?? "").trim();
  if (t === "") return null;
  const n = parseFloat(t);
  return Number.isFinite(n) ? n : null;
};

/* ---- 追加測点（タブ別） ---- */
const EXTRA_GROUPS = ["plan","profile","cross","output"];

const ensureExtraState = ()=> {
  state.extraStations = state.extraStations || {};
  state.nextExtraId = state.nextExtraId || {};
  for (const k of EXTRA_GROUPS) {
    if (!Array.isArray(state.extraStations[k])) state.extraStations[k] = [];
    if (!Number.isFinite(state.nextExtraId[k])) {
      const mx = Math.max(0, ...state.extraStations[k].map(r=>r.id||0));
      state.nextExtraId[k] = mx + 1;
    }
  }
};

const addExtrasFromText = (groupKey, text, pitch)=> {
  ensureExtraState();
  const parts = (String(text||"").trim())
    .split(/[\s,]+/)
    .map(s=>s.trim())
    .filter(Boolean);
  const errs = [];
  for (const tok of parts) {
    try {
      const mv = parseTokenToM(tok, pitch);
      state.extraStations[groupKey].push({ id: state.nextExtraId[groupKey]++, m: mv });
    } catch(e) {
      errs.push(`${tok}: ${e.message || e}`);
    }
  }
  return errs;
};

const bindExtraUI = (groupKey, rootEl, pitch)=> {
  ensureExtraState();
  const addBtn = document.getElementById(`addExtras_${groupKey}`);
  const ta = document.getElementById(`extraTokens_${groupKey}`);
  const clearBtn = document.getElementById(`clearExtras_${groupKey}`);

  if (addBtn && ta) {
    addBtn.onclick = ()=> {
      const txt = (ta.value||"").trim();
      if (!txt) return;
      const errs = addExtrasFromText(groupKey, txt, pitch);
      ta.value = "";
      saveState();
      if (errs.length) alert("追加エラー:\n" + errs.join("\n"));
      render();
    };
  }
  if (clearBtn) {
    clearBtn.onclick = ()=> {
      state.extraStations[groupKey] = [];
      state.nextExtraId[groupKey] = 1;
      saveState();
      render();
    };
  }

  if (!rootEl) return;
  rootEl.querySelectorAll(`input[data-ex-group="${groupKey}"][data-ex-id]`).forEach(inp=>{
    const id = parseInt(inp.getAttribute("data-ex-id"),10);
    inp.oninput = (e)=>{
      const row = state.extraStations[groupKey].find(x=>x.id===id);
      if (row) row.m = parseFloat(e.target.value)||0;
      saveState();
      render();
    };
  });
  rootEl.querySelectorAll(`button[data-ex-del][data-ex-group="${groupKey}"]`).forEach(btn=>{
    const id = parseInt(btn.getAttribute("data-ex-del"),10);
    btn.onclick = ()=>{
      state.extraStations[groupKey] = state.extraStations[groupKey].filter(x=>x.id!==id);
      saveState();
      render();
    };
  });
};



/* =========================
   Cross slope (横断)
========================= */
const ensureCrossState = ()=>{
  if (!state.cross || typeof state.cross !== 'object' || Array.isArray(state.cross)) {
    state.cross = {
      enabled: true,
      taper: { enabled: true, anchorRight: 3.000, anchorLeft: 3.000 },
      right: { segs: [], nextSegId: 1 },
      left:  { segs: [], nextSegId: 1 },
      overrides: {},
      ui: { selectedStaKey: "", previewTok: "" },
    };
  }
  if (!state.cross.overrides || typeof state.cross.overrides !== 'object' || Array.isArray(state.cross.overrides)) {
    state.cross.overrides = {};
  }
  if (!state.cross.ui || typeof state.cross.ui !== 'object' || Array.isArray(state.cross.ui)) {
    state.cross.ui = { selectedStaKey: "" };
  }
  if (typeof state.cross.ui.selectedStaKey !== "string") state.cross.ui.selectedStaKey = "";

  // taper
  if (!state.cross.taper || typeof state.cross.taper !== 'object' || Array.isArray(state.cross.taper)) {
    state.cross.taper = { enabled: true, anchorRight: 3.000, anchorLeft: 3.000 };
  }
  if (typeof state.cross.taper.enabled !== 'boolean') state.cross.taper.enabled = true;
  if (!Number.isFinite(Number(state.cross.taper.anchorRight))) state.cross.taper.anchorRight = 3.000;
  if (!Number.isFinite(Number(state.cross.taper.anchorLeft))) state.cross.taper.anchorLeft = 3.000;

  if (typeof state.cross.ui.previewTok !== 'string') state.cross.ui.previewTok = ;

  const ensureSide = (obj)=>{
    obj = (obj && typeof obj === 'object' && !Array.isArray(obj)) ? obj : { segs: [], nextSegId: 1 };
    if (!Array.isArray(obj.segs)) obj.segs = [];
    obj.segs = obj.segs.map((r, idx)=>({
      id: (r && Number.isFinite(r.id)) ? r.id : (idx + 1),
      end: Number(r && r.end),
      slopePct: Number.isFinite(Number(r && r.slopePct)) ? Number(r.slopePct) : 0,
    }));
    if (!Number.isFinite(obj.nextSegId)) {
      const mx = Math.max(0, ...obj.segs.map(r=>r.id||0));
      obj.nextSegId = mx + 1;
    }
    return obj;
  };

  state.cross.right = ensureSide(state.cross.right);
  state.cross.left  = ensureSide(state.cross.left);

  for (const k of Object.keys(state.cross.overrides)) {
    const ov = state.cross.overrides[k];
    if (!ov || typeof ov !== 'object' || Array.isArray(ov)) { delete state.cross.overrides[k]; continue; }
    ov.right = ensureSide(ov.right);
    ov.left  = ensureSide(ov.left);
  }

  const sel = state.cross.ui.selectedStaKey;
  if (sel && !state.cross.overrides[sel]) state.cross.ui.selectedStaKey = "";
};

const cloneCrossSide = (src)=>{
  const segs = (src?.segs || []).map((r, i)=>({
    id: i + 1,
    end: Number(r?.end) || 0,
    slopePct: Number(r?.slopePct) || 0,
  })).filter(r => Number.isFinite(r.end) && r.end > 0);
  const mx = Math.max(0, ...segs.map(r=>r.id||0));
  return { segs, nextSegId: mx + 1 };
};

const ensureCrossOverride = (staKey)=>{
  ensureCrossState();
  if (!staKey) return;
  if (!state.cross.overrides[staKey]) {
    state.cross.overrides[staKey] = {
      right: cloneCrossSide(state.cross.right),
      left:  cloneCrossSide(state.cross.left),
    };
  }
  const ov = state.cross.overrides[staKey];
  if (!ov.right) ov.right = cloneCrossSide(state.cross.right);
  if (!ov.left)  ov.left  = cloneCrossSide(state.cross.left);
};

const getCrossStore = (scope, side, staKey)=>{
  ensureCrossState();
  if (scope === "ovr") {
    ensureCrossOverride(staKey);
    return state.cross.overrides[staKey][side];
  }
  return state.cross[side];
};

const sortCrossSegs = (scope, side, staKey)=>{
  const store = getCrossStore(scope, side, staKey);
  store.segs.sort((a,b)=> (Number(a.end)||0) - (Number(b.end)||0));
};

const normalizeCrossToOuterEnd = (store, endVal)=>{
  endVal = Number(endVal);
  if (!Number.isFinite(endVal) || endVal <= 0) return;

  store.segs = Array.isArray(store.segs) ? store.segs.slice() : [];
  store.segs = store.segs
    .map((r, idx)=>({
      id: (r && Number.isFinite(r.id)) ? r.id : (idx + 1),
      end: Number(r && r.end),
      slopePct: Number.isFinite(Number(r && r.slopePct)) ? Number(r.slopePct) : 0,
    }))
    .filter(r => Number.isFinite(r.end) && r.end > 0);

  store.segs.sort((a,b)=>a.end-b.end);

  // endVal より外側の区間は削除
  store.segs = store.segs.filter(r => r.end <= endVal + 1e-9);

  if (!store.segs.length) {
    store.segs = [{ id: 1, end: Number(endVal.toFixed(3)), slopePct: 0.0 }];
    store.nextSegId = 2;
    return;
  }

  const last = store.segs[store.segs.length - 1];
  const prevEnd = (store.segs.length >= 2) ? store.segs[store.segs.length - 2].end : 0;
  last.end = Number(Math.max(endVal, prevEnd).toFixed(3));

  const mx = Math.max(0, ...store.segs.map(r=>r.id||0));
  if (!Number.isFinite(store.nextSegId)) store.nextSegId = mx + 1;
  store.nextSegId = Math.max(store.nextSegId, mx + 1);
};

const applyCrossOuterEnd = (rightEnd, leftEnd, affectOverrides)=>{
  ensureCrossState();
  normalizeCrossToOuterEnd(getCrossStore("common","right"), rightEnd);
  normalizeCrossToOuterEnd(getCrossStore("common","left"),  leftEnd);
  sortCrossSegs("common","right");
  sortCrossSegs("common","left");

  if (affectOverrides) {
    for (const k of Object.keys(state.cross.overrides || {})) {
      normalizeCrossToOuterEnd(getCrossStore("ovr","right", k), rightEnd);
      normalizeCrossToOuterEnd(getCrossStore("ovr","left",  k), leftEnd);
      sortCrossSegs("ovr","right", k);
      sortCrossSegs("ovr","left",  k);
    }
  }
};

const computeCrossSide = (scope, side, staKey)=>{
  const store = getCrossStore(scope, side, staKey);
  const segs = (store.segs||[]).slice().sort((a,b)=> (Number(a.end)||0) - (Number(b.end)||0));
  const warnings = [];
  let start = 0;
  let z = 0;
  const rows = [];

  for (const r of segs) {
    const end = Number(r.end);
    const slopePct = Number(r.slopePct)||0;
    if (!Number.isFinite(end) || end <= 0) { warnings.push('end<=0 の行があります'); continue; }
    const span = end - start;
    if (span < -1e-9) { warnings.push('距離が昇順ではありません'); continue; }
    if (Math.abs(span) < 1e-9) { warnings.push('同一距離(end)の行があります'); }
    const dz = (slopePct/100.0) * span;
    z += dz;
    rows.push({ id: r.id, start, end, slopePct, span, dz, zEnd: z });
    start = end;
  }
  return { rows, lastEnd: start, lastZ: z, warnings };
};


// ---- Cross taper + preview ----
const computeCrossRowsFromSegs = (segs)=>{
  segs = (Array.isArray(segs)?segs:[]).slice().sort((a,b)=> (Number(a.end)||0)-(Number(b.end)||0));
  const warnings = [];
  let start = 0;
  let z = 0;
  const rows = [];
  for (const r of segs) {
    const end = Number(r.end);
    const slopePct = Number(r.slopePct)||0;
    if (!Number.isFinite(end) || end <= 0) { warnings.push('end<=0 の行があります'); continue; }
    const span = end - start;
    if (span < -1e-9) { warnings.push('距離が昇順ではありません'); continue; }
    if (Math.abs(span) < 1e-9) { warnings.push('同一距離(end)の行があります'); }
    const dz = (slopePct/100.0) * span;
    z += dz;
    rows.push({ start, end, slopePct, dz, zEnd: z });
    start = end;
  }
  return { rows, lastEnd: start, lastZ: z, warnings };
};

const getCrossControlPoints = (side)=>{
  ensureCrossState();
  const pts = [];
  for (const k of Object.keys(state.cross.overrides||{})) {
    const m = Number(k);
    if (!Number.isFinite(m)) continue;
    const ov = state.cross.overrides[k];
    const store = ov && ov[side];
    const c = computeCrossRowsFromSegs(store?.segs||[]);
    if (Number.isFinite(c.lastEnd) && c.lastEnd > 0) pts.push({ m, w: c.lastEnd });
  }
  pts.sort((a,b)=>a.m-b.m);
  return pts;
};

const getCrossWidthAt = (m, side)=>{
  ensureCrossState();
  const base = computeCrossRowsFromSegs(state.cross[side]?.segs||[]);
  const baseW = base.lastEnd || 0;
  const pts = getCrossControlPoints(side);
  const mk = Number(Number(m).toFixed(3));

  for (const p of pts) {
    if (Math.abs(p.m - mk) < 1e-6) return { w: p.w, mode: '制御点', prev: p, next: p, baseW };
  }

  let prev = null, next = null;
  for (const p of pts) {
    if (p.m < mk) prev = p;
    else if (p.m > mk) { next = p; break; }
  }

  if (prev && next) {
    const t = (mk - prev.m) / Math.max(1e-9, (next.m - prev.m));
    return { w: prev.w + (next.w - prev.w)*t, mode: '線形補間', prev, next, baseW };
  }
  if (prev) return { w: prev.w, mode: '前の制御点保持', prev, next, baseW };
  if (next) return { w: next.w, mode: '後の制御点保持', prev, next, baseW };
  return { w: baseW, mode: '共通', prev, next, baseW };
};

const widenCrossSegsFromCommon = (commonSegs, targetW, anchor)=>{
  commonSegs = (Array.isArray(commonSegs)?commonSegs:[]).slice().sort((a,b)=> (Number(a.end)||0)-(Number(b.end)||0));
  const base = computeCrossRowsFromSegs(commonSegs);
  const baseW = base.lastEnd || 0;
  targetW = Number(targetW);
  if (!Number.isFinite(targetW) || targetW <= 0) targetW = baseW;

  anchor = Number(anchor);
  if (!Number.isFinite(anchor) || anchor < 0) anchor = 0;

  // targetW が anchor より小さい場合は anchor にクランプ
  if (targetW < anchor) targetW = anchor;

  const delta = targetW - baseW;
  if (Math.abs(delta) < 1e-9) {
    // 念のため最後を targetW に合わせる
    const out = commonSegs.map((r,i)=>({ id: i+1, end: Number(r.end), slopePct: Number(r.slopePct)||0 }));
    if (out.length) out[out.length-1].end = Number(targetW.toFixed(3));
    return out;
  }

  const out = [];
  let start = 0;
  for (const r of commonSegs) {
    const end = Number(r.end);
    const slopePct = Number(r.slopePct)||0;
    if (!Number.isFinite(end) || end <= 0) continue;

    if (end <= anchor + 1e-9) {
      out.push({ end, slopePct });
    } else if (start < anchor - 1e-9 && end > anchor + 1e-9) {
      // cross anchor -> split
      out.push({ end: anchor, slopePct });
      out.push({ end: end + delta, slopePct });
    } else {
      out.push({ end: end + delta, slopePct });
    }
    start = end;
  }

  // 0以下/逆転を除去しつつ、targetW でトリム
  const cleaned = [];
  let last = 0;
  for (const r of out.sort((a,b)=>a.end-b.end)) {
    let e = Number(r.end);
    if (!Number.isFinite(e)) continue;
    if (e <= last + 1e-9) continue;
    if (e > targetW + 1e-9) continue;
    cleaned.push({ end: e, slopePct: Number(r.slopePct)||0 });
    last = e;
  }

  if (!cleaned.length) {
    cleaned.push({ end: Number(targetW.toFixed(3)), slopePct: 0.0 });
  } else {
    const prevEnd = (cleaned.length>=2) ? cleaned[cleaned.length-2].end : 0;
    cleaned[cleaned.length-1].end = Number(Math.max(targetW, prevEnd).toFixed(3));
  }

  return cleaned.map((r,i)=>({ id: i+1, end: Number(r.end), slopePct: Number(r.slopePct)||0 }));
};

const getEffectiveCrossSegsAt = (m, side)=>{
  ensureCrossState();
  const key = Number(m).toFixed(3);
  const hasOvr = !!(state.cross.overrides && state.cross.overrides[key]);
  const taperOn = !!(state.cross.taper && state.cross.taper.enabled);

  if (hasOvr) {
    const segs = (state.cross.overrides[key][side]?.segs||[]).slice();
    const info = { source: '例外', width: computeCrossRowsFromSegs(segs).lastEnd || 0, mode: '制御点' };
    return { segs, info };
  }

  const commonSegs = (state.cross[side]?.segs||[]).slice();
  if (!taperOn) {
    const info = { source: '共通', width: computeCrossRowsFromSegs(commonSegs).lastEnd || 0, mode: '共通' };
    return { segs: commonSegs, info };
  }

  const wInfo = getCrossWidthAt(m, side);
  const anchor = (side==='right') ? Number(state.cross.taper.anchorRight) : Number(state.cross.taper.anchorLeft);
  const segs = widenCrossSegsFromCommon(commonSegs, wInfo.w, anchor);
  const info = { source: '割付', width: wInfo.w, mode: wInfo.mode, prev: wInfo.prev, next: wInfo.next };
  return { segs, info };
};

const setOverrideWidthFromCommon = (staKey, rightW, leftW)=>{
  ensureCrossOverride(staKey);
  const ar = Number(state.cross.taper?.anchorRight ?? 0);
  const al = Number(state.cross.taper?.anchorLeft ?? 0);
  if (Number.isFinite(rightW) && rightW>0) {
    state.cross.overrides[staKey].right.segs = widenCrossSegsFromCommon(state.cross.right.segs, rightW, ar);
    state.cross.overrides[staKey].right.nextSegId = Math.max(1, state.cross.overrides[staKey].right.segs.length + 1);
  }
  if (Number.isFinite(leftW) && leftW>0) {
    state.cross.overrides[staKey].left.segs = widenCrossSegsFromCommon(state.cross.left.segs, leftW, al);
    state.cross.overrides[staKey].left.nextSegId = Math.max(1, state.cross.overrides[staKey].left.segs.length + 1);
  }
};

const drawCrossPreviewCanvas = (canvas, pts, labels)=>{
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  const pad = 30;
  const xs = pts.map(p=>p.x);
  const zs = pts.map(p=>p.z);
  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minZ = Math.min(...zs), maxZ = Math.max(...zs);
  const dx = Math.max(1e-6, maxX - minX);
  const dz = Math.max(1e-6, maxZ - minZ);
  // add margin
  minX -= dx*0.08; maxX += dx*0.08;
  minZ -= dz*0.15; maxZ += dz*0.15;

  const sx = (W - pad*2) / Math.max(1e-6, (maxX - minX));
  const sy = (H - pad*2) / Math.max(1e-6, (maxZ - minZ));

  const tx = (x)=> pad + (x - minX) * sx;
  const ty = (z)=> H - pad - (z - minZ) * sy;

  // axes
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#cbd5e1';
  ctx.beginPath();
  ctx.moveTo(tx(0), pad);
  ctx.lineTo(tx(0), H-pad);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(pad, ty(0));
  ctx.lineTo(W-pad, ty(0));
  ctx.stroke();

  // polyline
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#2563eb';
  ctx.beginPath();
  for (let i=0;i<pts.length;i++) {
    const p = pts[i];
    const X = tx(p.x), Y = ty(p.z);
    if (i===0) ctx.moveTo(X,Y);
    else ctx.lineTo(X,Y);
  }
  ctx.stroke();

  // points
  ctx.fillStyle = '#0f172a';
  for (const p of pts) {
    const X = tx(p.x), Y = ty(p.z);
    ctx.beginPath();
    ctx.arc(X,Y,3,0,Math.PI*2);
    ctx.fill();
  }

  // labels (optional)
  if (labels && labels.length) {
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = '#334155';
    for (const l of labels) {
      const X = tx(l.x), Y = ty(l.z);
      ctx.fillText(l.text, X+6, Y-6);
    }
  }
};


const setCrossExample = (scope, side, staKey)=>{
  const store = getCrossStore(scope, side, staKey);
  store.segs = [
    { id: 1, end: 3.000, slopePct: -2.000 },
    { id: 2, end: 4.500, slopePct:  0.000 },
    { id: 3, end: 5.000, slopePct: -1.000 },
  ];
  store.nextSegId = 4;
  saveState();
  render();
};

const bindCrossSlopeUI = (rootEl)=>{
  ensureCrossState();

  const bindSide = (side, scope, staKey)=>{
    const suffix = (scope === "ovr") ? `ovr_${side}` : side;
    const addBtn = document.getElementById(`addCrossSeg_${suffix}`);
    const clearBtn = document.getElementById(`clearCrossSeg_${suffix}`);
    const exBtn = document.getElementById(`exampleCrossSeg_${suffix}`);

    if (addBtn) {
      addBtn.onclick = ()=>{
        const store = getCrossStore(scope, side, staKey);
        const last = Math.max(0, ...(store.segs||[]).map(r=>Number(r.end)||0));
        store.segs.push({ id: store.nextSegId++, end: Number((last + 1.0).toFixed(3)), slopePct: 0.0 });
        sortCrossSegs(scope, side, staKey);
        saveState();
        render();
      };
    }
    if (clearBtn) {
      clearBtn.onclick = ()=>{
        const store = getCrossStore(scope, side, staKey);
        store.segs = [];
        store.nextSegId = 1;
        saveState();
        render();
      };
    }
    if (exBtn) {
      exBtn.onclick = ()=> setCrossExample(scope, side, staKey);
    }

    if (!rootEl) return;

    const staSel = (scope === "ovr" && staKey) ? `[data-xs-sta="${staKey}"]` : ``;

    rootEl.querySelectorAll(`input[data-xs-scope="${scope}"]${staSel}[data-xs-side="${side}"][data-xs-end]`).forEach(inp=>{
      const id = parseInt(inp.getAttribute('data-xs-id'),10);
      inp.oninput = (e)=>{
        const store = getCrossStore(scope, side, staKey);
        const r = (store.segs||[]).find(x=>x.id===id);
        if (r) r.end = parseFloat(e.target.value)||0;
        sortCrossSegs(scope, side, staKey);
        saveState();
        render();
      };
    });

    rootEl.querySelectorAll(`input[data-xs-scope="${scope}"]${staSel}[data-xs-side="${side}"][data-xs-slope]`).forEach(inp=>{
      const id = parseInt(inp.getAttribute('data-xs-id'),10);
      inp.oninput = (e)=>{
        const store = getCrossStore(scope, side, staKey);
        const r = (store.segs||[]).find(x=>x.id===id);
        if (r) r.slopePct = parseFloat(e.target.value)||0;
        saveState();
        render();
      };
    });

    rootEl.querySelectorAll(`button[data-xs-scope="${scope}"]${staSel}[data-xs-side="${side}"][data-xs-del]`).forEach(btn=>{
      const id = parseInt(btn.getAttribute('data-xs-del'),10);
      btn.onclick = ()=>{
        const store = getCrossStore(scope, side, staKey);
        store.segs = (store.segs||[]).filter(x=>x.id!==id);
        saveState();
        render();
      };
    });
  };

  // 共通
  bindSide('right', 'common');
  bindSide('left',  'common');

  // 測点別（選択中のみ）
  const sel = state.cross.ui.selectedStaKey;
  if (sel && state.cross.overrides && state.cross.overrides[sel]) {
    bindSide('right', 'ovr', sel);
    bindSide('left',  'ovr', sel);
  }
};

/* =========================
   Profile (Vertical)
========================= */
const toDecGrade = (pct) => (Number(pct) || 0) / 100.0;

const buildProfileModel = (prof, totalPlan) => {
  const warnings = [];
  if (!prof?.enabled) return { ok: false, pv: [], segments: [], curves: [], warnings };

  const grades = (prof.grades || [])
    .filter(r => Number.isFinite(r.nextSta) && Number.isFinite(r.gradePct))
    .slice()
    .sort((a, b) => Number(a.nextSta) - Number(b.nextSta));

  const s0 = Number(prof.startSta) || 0;
  const z0 = Number(prof.startZ) || 0;

  const pv = [{ sta: s0, z: z0 }];
  let curSta = s0, curZ = z0;

  for (const r of grades) {
    const s1 = Number(r.nextSta);
    const g = toDecGrade(Number(r.gradePct));
    if (!(s1 > curSta)) {
      warnings.push(`縦断: nextStaが増加していません（${s1.toFixed(3)}）`);
      continue;
    }
    curZ = curZ + g * (s1 - curSta);
    curSta = s1;
    pv.push({ sta: curSta, z: curZ });
  }

  if (Number.isFinite(totalPlan) && pv.length >= 2) {
    const lastSta = pv[pv.length - 1].sta;
    if (totalPlan > lastSta + 1e-6) {
      const lastGrade = grades.length ? grades[grades.length - 1] : { gradePct: 0 };
      const gLast = toDecGrade(Number(lastGrade.gradePct));
      const zEnd = pv[pv.length - 1].z + gLast * (totalPlan - lastSta);
      pv.push({ sta: totalPlan, z: zEnd });
      warnings.push(`縦断: 終点測点が平面総延長(${totalPlan.toFixed(3)})に届かないため、最後勾配で延長しました`);
    } else if (totalPlan < lastSta - 1e-6) {
      warnings.push(`縦断: 勾配終点(${lastSta.toFixed(3)})が平面総延長(${totalPlan.toFixed(3)})を超えています（出力は平面総延長まで）`);
    }
  }

  // segments: pv[i] -> pv[i+1] は grades[i] の勾配
  const segments = [];
  for (let i = 0; i < pv.length - 1; i++) {
    const staA = pv[i].sta, staB = pv[i + 1].sta;
    const src = grades[i] || grades[grades.length - 1] || { gradePct: 0 };
    const gPct = Number(src.gradePct ?? 0);
    segments.push({ s0: staA, s1: staB, z0: pv[i].z, gDec: toDecGrade(gPct) });
  }

  // VPI曲線（VPI単位）
  const curves = [];
  const pvKeys = new Set([...(pv.slice(1, -1).map(p => p.sta.toFixed(3)))]);

  // 重複チェック（同一VPIに複数）
  const vcMap = new Map();
  for (const vc of (prof.vcurves || [])) {
    const vpiSta = Number(vc.vpiSta);
    if (!Number.isFinite(vpiSta)) continue;
    const key = vpiSta.toFixed(3);
    if (vcMap.has(key)) warnings.push(`縦断: VPI@${key} に縦断曲線が重複しています（最後の設定を使用）`);
    vcMap.set(key, vc);
  }

  // PVに存在しないVPI指定
  for (const key of vcMap.keys()) {
    if (!pvKeys.has(key)) warnings.push(`縦断: 縦断曲線のVPI測点(${key})がPV点に存在しません（スキップ）`);
  }

  for (let i = 1; i < pv.length - 1; i++) {
    const vpiSta = pv[i].sta;
    const key = vpiSta.toFixed(3);
    const spec = vcMap.get(key);
    if (!spec) continue;

    const prevSeg = segments[i - 1];
    const nextSeg = segments[i];
    if (!prevSeg || !nextSeg) continue;

    const g1 = prevSeg.gDec;
    const g2 = nextSeg.gDec;
    const A = g2 - g1;

    let L = Number(spec.L);
    const ymax = (spec.ymax == null ? NaN : Number(spec.ymax));

    if (!Number.isFinite(L) || L <= 0) {
      if (Number.isFinite(ymax) && ymax > 0) {
        if (Math.abs(A) < 1e-12) {
          warnings.push(`縦断: VPI@${key} で勾配差0のため ymax→L換算できません`);
          continue;
        }
        L = 8 * ymax / Math.abs(A);
      } else {
        continue;
      }
    }

    if (Number.isFinite(ymax) && ymax > 0 && Number.isFinite(L) && L > 0 && Math.abs(A) > 1e-12) {
      const ycalc = Math.abs(A) * L / 8;
      if (Math.abs(ycalc - ymax) > 0.005) {
        warnings.push(`縦断: VPI@${key} のymax不一致（入力=${ymax.toFixed(3)} / 計算=${ycalc.toFixed(3)}）`);
      }
    }

    // 前後区間をはみ出さない最大L
    const maxL = 2 * Math.min(vpiSta - prevSeg.s0, nextSeg.s1 - vpiSta);
    if (maxL <= 0) continue;
    if (L > maxL) {
      warnings.push(`縦断: VPI@${key} のL(${L.toFixed(3)})が長すぎるため、最大(${maxL.toFixed(3)})に縮めました`);
      L = maxL;
    }

    const bvc = vpiSta - L / 2;
    const evc = vpiSta + L / 2;

    const zVPI = pv[i].z;
    const zBVC = zVPI - g1 * (L / 2);

    curves.push({ s0: bvc, s1: evc, L, zBVC, g1, A });
  }

  return { ok: true, pv, segments, curves, warnings };
};

const evalProfileZ = (model, s) => {
  if (!model?.ok) return NaN;

  for (const c of model.curves) {
    if (s >= c.s0 - 1e-9 && s <= c.s1 + 1e-9) {
      const x = clamp(s - c.s0, 0, c.L);
      return c.zBVC + c.g1 * x + (c.A / (2 * c.L)) * x * x;
    }
  }

  const segs = model.segments || [];
  if (!segs.length) return NaN;

  if (s <= segs[0].s0) return segs[0].z0;
  const last = segs[segs.length - 1];
  if (s >= last.s1) return last.z0 + last.gDec * (last.s1 - last.s0);

  for (const seg of segs) {
    if (s >= seg.s0 - 1e-9 && s <= seg.s1 + 1e-9) {
      return seg.z0 + seg.gDec * (s - seg.s0);
    }
  }
  return NaN;
};


/* =========================
   Segment classes (Plan)
========================= */
class SegmentStraight {
  constructor(s0, Ax, Ay, Bx, By) {
    this.type = "straight";
    this.s0 = s0;
    const L = norm(Bx - Ax, By - Ay);
    this.s1 = s0 + L;
    this.length = L;
    this.Ax = Ax; this.Ay = Ay;
    this.Bx = Bx; this.By = By;
    const [ux, uy] = unit(Bx - Ax, By - Ay);
    this.az = azFromVec(ux, uy);
  }
  eval(s) {
    const t = this.length === 0 ? 0 : clamp((s - this.s0) / this.length, 0, 1);
    return { N: this.Ay + t * (this.By - this.Ay), E: this.Ax + t * (this.Bx - this.Ax), az: this.az };
  }
}

class SegmentArc {
  constructor(s0, x0, y0, psi0, R, L, turnSign) {
    this.type = "arc";
    this.s0 = s0; this.s1 = s0 + L; this.length = L;
    this.R = R; this.turnSign = turnSign;
    this.x0 = x0; this.y0 = y0; this.psi0 = psi0;

    const nxL = -Math.sin(psi0), nyL = Math.cos(psi0);
    this.cx = x0 + turnSign * nxL * R;
    this.cy = y0 + turnSign * nyL * R;
    this.rx0 = x0 - this.cx;
    this.ry0 = y0 - this.cy;
  }
  eval(s) {
    const u = clamp(s - this.s0, 0, this.length);
    const ang = this.turnSign * (u / this.R);
    const ca = Math.cos(ang), sa = Math.sin(ang);

    const rx = ca * this.rx0 - sa * this.ry0;
    const ry = sa * this.rx0 + ca * this.ry0;

    const E = this.cx + rx;
    const N = this.cy + ry;

    const rL = norm(rx, ry);
    let psi = this.psi0;
    if (rL > 0) {
      const tE = -this.turnSign * ry;
      const tN =  this.turnSign * rx;
      psi = Math.atan2(tN, tE);
    }
    return { N, E, az: azFromPsi(psi) };
  }
}

class SegmentSpiral {
  constructor(s0, x0, y0, psi0, R, Ls, turnSign, mode, ds) {
    this.type = "spiral";
    this.s0 = s0; this.s1 = s0 + Ls; this.length = Ls;
    this.R = R;
    this.turnSign = turnSign;

    const n = Math.max(1, Math.ceil(Ls / Math.max(ds, 1e-6)));
    const step = Ls / n;

    this.ss = [0]; this.xs = [x0]; this.ys = [y0]; this.psis = [psi0];
    let x = x0, y = y0, psi = psi0;

    for (let i = 1; i <= n; i++) {
      const sMid = (i - 0.5) * step;
      const k = (mode === "in" ? sMid / Ls : 1 - sMid / Ls) / R;
      psi += turnSign * k * step;
      x += Math.cos(psi) * step;
      y += Math.sin(psi) * step;
      this.ss.push(i * step);
      this.xs.push(x);
      this.ys.push(y);
      this.psis.push(psi);
    }
  }
  endState() {
    const last = this.ss.length - 1;
    return { x: this.xs[last], y: this.ys[last], psi: this.psis[last] };
  }
  eval(s) {
    const u = clamp(s - this.s0, 0, this.length);
    if (u <= 0) return { N: this.ys[0], E: this.xs[0], az: azFromPsi(this.psis[0]) };
    if (u >= this.length) {
      const last = this.ss.length - 1;
      return { N: this.ys[last], E: this.xs[last], az: azFromPsi(this.psis[last]) };
    }
    let j = 0;
    while (j + 1 < this.ss.length && this.ss[j + 1] < u) j++;
    const t = (u - this.ss[j]) / (this.ss[j + 1] - this.ss[j]);
    const x = this.xs[j] + t * (this.xs[j + 1] - this.xs[j]);
    const y = this.ys[j] + t * (this.ys[j + 1] - this.ys[j]);
    const psi = this.psis[j] + t * (this.psis[j + 1] - this.psis[j]);
    return { N: y, E: x, az: azFromPsi(psi) };
  }
}

const evalAlignment = (segments, s) => {
  if (!segments?.length) return { N: 0, E: 0, az: 0 };
  if (s <= segments[0].s0) return segments[0].eval(segments[0].s0);
  if (s >= segments[segments.length - 1].s1) return segments[segments.length - 1].eval(segments[segments.length - 1].s1);
  for (const seg of segments) {
    if (s >= seg.s0 - 1e-9 && s <= seg.s1 + 1e-9) return seg.eval(s);
  }
  return segments[segments.length - 1].eval(segments[segments.length - 1].s1);
};

/* =========================
   Alignment computation
========================= */
const computeAlignment = (ipPoints, curveSettings, dsSpiral, clothoidMode) => {
  if (ipPoints.length < 2) return { segments: [], keypoints: [], total: 0, warnings: ["点が2点未満です"] };

  const warnings = [];
  const segments = [];
  const keypoints = [];

  let curX = ipPoints[0].E, curY = ipPoints[0].N, curSta = 0;

  {
    const [ux, uy] = unit(ipPoints[1].E - curX, ipPoints[1].N - curY);
    keypoints.push({ name: ipPoints[0].name, sta: 0, N: curY, E: curX, az: azFromVec(ux, uy) });
  }

  for (let i = 1; i < ipPoints.length - 1; i++) {
    const prev = ipPoints[i - 1], curr = ipPoints[i], next = ipPoints[i + 1];
    const [dinx, diny] = unit(curr.E - prev.E, curr.N - prev.N);
    const [doutx, douty] = unit(next.E - curr.E, next.N - curr.N);

    const Delta = Math.acos(clamp(dot(dinx, diny, doutx, douty), -1, 1));
    const cs = curveSettings.find(c => c.ipName === curr.name);

    if (!cs || cs.R <= 0 || Delta < 1e-9 || cs.direction === "none") {
      if (norm(curr.E - curX, curr.N - curY) > 1e-9) {
        const seg = new SegmentStraight(curSta, curX, curY, curr.E, curr.N);
        segments.push(seg);
        curSta = seg.s1; curX = curr.E; curY = curr.N;
      }
      continue;
    }

    const R = cs.R;

    let L1, L2;
    if (clothoidMode === "A") {
      const A1 = cs.A1 || 0, A2 = (cs.A2 ?? A1);
      L1 = R > 0 ? (A1 * A1) / R : 0;
      L2 = R > 0 ? (A2 * A2) / R : 0;
    } else {
      L1 = cs.Ls || 0;
      L2 = cs.Ls || 0;
    }

    const z = crossZ(dinx, diny, doutx, douty);
    const turnSign =
      cs.direction === "left" ? 1 :
      cs.direction === "right" ? -1 :
      (z >= 0 ? 1 : -1);

    const theta1 = L1 > 0 ? L1 / (2 * R) : 0;
    const theta2 = L2 > 0 ? L2 / (2 * R) : 0;
    const p = (L1 * L1 + L2 * L2) / (48 * R);
    const DeltaC = Delta - theta1 - theta2;

    if (DeltaC < -1e-9) {
      warnings.push(`${curr.name}: クロソイド長が長すぎ（ΔC<0）`);
      continue;
    }

    const T = (R + p) * Math.tan(Delta / 2) + (L1 + L2) / 4;
    const Lc = R * Math.max(0, DeltaC);

    const distIn = norm(curr.E - prev.E, curr.N - prev.N);
    const distOut = norm(next.E - curr.E, next.N - curr.N);

    if (distIn <= T + 1e-6 || distOut <= T + 1e-6) {
      warnings.push(`${curr.name}: 接線長不足`);
      continue;
    }

    const TSx = curr.E - dinx * T, TSy = curr.N - diny * T;
    const STx = curr.E + doutx * T, STy = curr.N + douty * T;

    if (norm(TSx - curX, TSy - curY) > 1e-9) {
      const seg = new SegmentStraight(curSta, curX, curY, TSx, TSy);
      segments.push(seg);
      curSta = seg.s1; curX = TSx; curY = TSy;
    }

    const azTS = azFromVec(dinx, diny);
    const psiTS = psiFromAz(azTS);
    const staTSstart = curSta;
    let psiSC = psiTS;

    if (L1 > 0) {
      const sp = new SegmentSpiral(curSta, curX, curY, psiTS, R, L1, turnSign, "in", dsSpiral);
      segments.push(sp);
      curSta = sp.s1;
      const end = sp.endState();
      curX = end.x; curY = end.y; psiSC = end.psi;
    }

    const staSC = curSta;
    let psiCS = psiSC;

    if (Lc > 0) {
      const arc = new SegmentArc(curSta, curX, curY, psiSC, R, Lc, turnSign);
      segments.push(arc);
      curSta = arc.s1;
      const end = arc.eval(arc.s1);
      curX = end.E; curY = end.N;
      psiCS = psiFromAz(end.az);
    }

    const staCS = curSta;

    if (L2 > 0) {
      const sp = new SegmentSpiral(curSta, curX, curY, psiCS, R, L2, turnSign, "out", dsSpiral);
      segments.push(sp);
      curSta = sp.s1;
      const end = sp.endState();
      curX = end.x; curY = end.y;
    }

    const staST = curSta;

    const err = norm(STx - curX, STy - curY);
    if (err > Math.max(0.05, dsSpiral * 0.2)) warnings.push(`${curr.name}: ST誤差 ${err.toFixed(3)}m`);
    curX = STx; curY = STy;

    for (const [nm, sta] of [[`TS(${curr.name})`, staTSstart], [`SC(${curr.name})`, staSC], [`CS(${curr.name})`, staCS], [`ST(${curr.name})`, staST]]) {
      const pt = evalAlignment(segments, sta);
      keypoints.push({ name: nm, sta, N: pt.N, E: pt.E, az: pt.az });
    }
    keypoints.push({ name: `PI(${curr.name})`, sta: NaN, N: curr.N, E: curr.E, az: azTS });
  }

  const last = ipPoints[ipPoints.length - 1];
  if (norm(last.E - curX, last.N - curY) > 1e-9) {
    const seg = new SegmentStraight(curSta, curX, curY, last.E, last.N);
    segments.push(seg);
    curSta = seg.s1;
  }

  if (ipPoints.length >= 2) {
    const prev = ipPoints[ipPoints.length - 2];
    const [ux, uy] = unit(last.E - prev.E, last.N - prev.N);
    keypoints.push({ name: last.name, sta: curSta, N: last.N, E: last.E, az: azFromVec(ux, uy) });
  }

  return { segments, keypoints, total: curSta, warnings };
};

/* =========================
   Work points + stations
========================= */
const getWorkPoints = () => {
  const k = Math.max(0, Math.min(state.useIpCount, state.ipPoints.length));
  const mid = state.ipPoints.slice(0, k).map(p => ({ name: p.name, N: p.N, E: p.E }));
  return dedupeConsecutivePoints([
    { name: state.bp.name || "BP", N: state.bp.N, E: state.bp.E },
    ...mid,
    { name: state.ep.name || "EP", N: state.ep.N, E: state.ep.E },
  ]);
};

const buildUnifiedStationList = (total, stepInt, sources) => {
  stepInt = Math.max(1, Math.floor(stepInt || 1));

  const base = [];
  for (let s = 0; s < total - 1e-9; s += stepInt) base.push(s);
  base.push(total);

  const extrasIn = [];
  const notes = [];

  for (const src of sources || []) {
    const label = src?.label || "追加測点";
    const values = src?.values || [];
    for (const v of values) {
      if (!Number.isFinite(v)) continue;
      if (v < -1e-9 || v > total + 1e-9) notes.push(`${label} ${v.toFixed(3)}m は範囲外なので除外`);
      else extrasIn.push(clamp(v, 0, total));
    }
  }

  const merged = [...base, ...extrasIn].sort((a, b) => a - b);
  return { stations: dedupeSorted(merged), notes, baseCount: base.length, extraCount: extrasIn.length };
};

/* =========================
   Canvas plot (left/right)
========================= */
function drawPlanCanvas(canvas, segments, workPoints, keypoints, options) {
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  const samples = [];
  for (const seg of segments) {
    if (!seg || !seg.length || seg.length <= 0) continue;
    const t = seg.type;
    let ss = [];
    if (t === "straight") ss = [seg.s0, seg.s1];
    else {
      const n = Math.max(2, Math.ceil(seg.length / Math.max(options.plotStep, 0.1)) + 1);
      for (let i=0;i<n;i++) ss.push(seg.s0 + i*(seg.length/(n-1)));
    }
    const pts = ss.map(s => ({...evalAlignment(segments, s), s}));
    samples.push({ seg, pts });
  }
  if (!samples.length) return;

  let minE=Infinity, maxE=-Infinity, minN=Infinity, maxN=-Infinity;
  const pushPt = (E,N)=>{ minE=Math.min(minE,E); maxE=Math.max(maxE,E); minN=Math.min(minN,N); maxN=Math.max(maxN,N); };
  for (const block of samples) for (const p of block.pts) pushPt(p.E, p.N);
  for (const p of workPoints) pushPt(p.E, p.N);
  if (options.showKeypoints) for (const k of keypoints) if (Number.isFinite(k.sta)) pushPt(k.E, k.N);

  const pad = 30;
  const dx = Math.max(1e-9, maxE - minE);
  const dy = Math.max(1e-9, maxN - minN);
  const sx = (W - pad*2) / dx;
  const sy = (H - pad*2) / dy;
  const s = Math.min(sx, sy);

  const toXY = (E,N) => {
    const x = pad + (E - minE) * s;
    const y = H - (pad + (N - minN) * s);
    return [x,y];
  };

  const strokeFor = (seg) => {
    if (seg.type === "straight") return { w:2, col:"#0f172a" };
    const ts = seg.turnSign || 0;
    if (ts > 0) return { w:3, col:"#2563eb" };
    if (ts < 0) return { w:3, col:"#ef4444" };
    return { w:3, col:"#9333ea" };
  };

  for (const block of samples) {
    const {seg, pts} = block;
    const st = strokeFor(seg);
    ctx.beginPath();
    for (let i=0;i<pts.length;i++){
      const [x,y] = toXY(pts[i].E, pts[i].N);
      if (i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.lineWidth = st.w;
    ctx.strokeStyle = st.col;
    ctx.stroke();

    if (options.showArrow && pts.length >= 2) {
      const mid = Math.floor(pts.length/2);
      const p0 = pts[mid], p1 = pts[Math.min(mid+1, pts.length-1)];
      const [x0,y0] = toXY(p0.E,p0.N);
      const [x1,y1] = toXY(p1.E,p1.N);
      const ang = Math.atan2(y1-y0, x1-x0);
      const L = 10;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x1 - L*Math.cos(ang-0.5), y1 - L*Math.sin(ang-0.5));
      ctx.lineTo(x1 - L*Math.cos(ang+0.5), y1 - L*Math.sin(ang+0.5));
      ctx.closePath();
      ctx.fillStyle = st.col;
      ctx.fill();
    }
  }

  ctx.fillStyle = "#111827";
  for (const p of workPoints) {
    const [x,y] = toXY(p.E,p.N);
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    ctx.font = "12px system-ui";
    ctx.fillText(" " + p.name, x+6, y-6);
  }

  if (options.showKeypoints) {
    ctx.fillStyle = "#334155";
    ctx.font = "11px system-ui";
    for (const k of keypoints) {
      if (!Number.isFinite(k.sta)) continue;
      const [x,y] = toXY(k.E,k.N);
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
      ctx.fillText(" " + k.name, x+6, y+12);
    }
  }

  const lx=10, ly=10;
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.strokeStyle = "#e2e8f0";
  ctx.lineWidth = 1;
  if (ctx.roundRect) {
    ctx.beginPath();
    ctx.roundRect(lx,ly,240,78,10);
    ctx.fill(); ctx.stroke();
  } else {
    ctx.fillRect(lx,ly,240,78);
    ctx.strokeRect(lx,ly,240,78);
  }

  const rows = [
    { label:"直線", col:"#0f172a" },
    { label:"曲線（左）", col:"#2563eb" },
    { label:"曲線（右）", col:"#ef4444" },
  ];
  ctx.font = "12px system-ui";
  for (let i=0;i<rows.length;i++){
    const y = ly + 22 + i*18;
    ctx.strokeStyle = rows[i].col;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(lx+12, y); ctx.lineTo(lx+50, y); ctx.stroke();
    ctx.fillStyle = "#0f172a";
    ctx.fillText(rows[i].label, lx+60, y+4);
  }
}

/* =========================
   Rendering
========================= */
const viewPlan = document.getElementById("viewPlan");
const viewProfile = document.getElementById("viewProfile");
const viewCross = document.getElementById("viewCross");
const viewOutput = document.getElementById("viewOutput");
const viewSave = document.getElementById("viewSave");

const computeAll = () => {
  const workPoints = getWorkPoints();
  const res = computeAlignment(workPoints, state.curveSettings, state.dsSpiral, state.clothoidMode);
  return { workPoints, res };
};

const render = () => {
  document.getElementById("projectName").value = state.projectName;
  document.getElementById("coordDecimals").value = String(state.coordDecimals);
  document.getElementById("staPitch").value = state.staPitch;
  document.getElementById("outputStep").value = state.outputStep;
  document.getElementById("dsSpiral").value = state.dsSpiral;
  document.getElementById("clothoidMode").value = state.clothoidMode;

  const d = Math.max(0, Math.min(4, parseInt(state.coordDecimals, 10) || 3));
  const { workPoints, res } = computeAll();
  const pitch = Math.max(1, Math.floor(state.staPitch||1));

  /* -------- PLAN -------- */
  viewPlan.innerHTML = `
    <div class="card" id="secPlan">
      <h2>平面線形：BP / EP（座標m）</h2>
      <div class="grid grid-2">
        <div>
          <div class="pill">BP</div>
          <div class="grid grid-2" style="margin-top:8px;">
            <div><label>N</label><input id="bpN" type="number" step="0.001" /></div>
            <div><label>E</label><input id="bpE" type="number" step="0.001" /></div>
          </div>
        </div>
        <div>
          <div class="pill">EP</div>
          <div class="grid grid-2" style="margin-top:8px;">
            <div><label>N</label><input id="epN" type="number" step="0.001" /></div>
            <div><label>E</label><input id="epE" type="number" step="0.001" /></div>
          </div>
        </div>
      </div>
      <div class="mini" style="margin-top:8px;">座標は m。通常は小数3桁、必要に応じて4桁。</div>
    </div>

    <div class="card">
      <h2>IP点（BP→IP1..IPk→EP）</h2>
      <div class="grid grid-3">
        <div>
          <label>使用IP数（IP1から）</label>
          <input id="useIpCount" type="range" min="0" max="${state.ipPoints.length}" />
          <div class="mini"><span id="useIpLabel"></span></div>
        </div>
        <div>
          <button class="btn" id="addIP">+ IP追加</button>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="resetDemo">デモ値に戻す</button>
        </div>
        <div>
          <label>IP削除（名前指定）</label>
          <select id="delIpSel">
            <option value="">（選択）</option>
            ${state.ipPoints.map(p=>`<option value="${p.id}">${p.name}</option>`).join("")}
          </select>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="delIP">選択IPを削除</button>
        </div>
      </div>

      <div style="overflow:auto; margin-top:10px;">
        <table>
          <thead><tr><th>IP名</th><th>N</th><th>E</th></tr></thead>
          <tbody>
            ${state.ipPoints.map(p=>`
              <tr>
                <td><input data-ip-name="${p.id}" value="${p.name}" /></td>
                <td><input data-ip-n="${p.id}" type="number" step="0.001" value="${p.N}" /></td>
                <td><input data-ip-e="${p.id}" type="number" step="0.001" value="${p.E}" /></td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>曲線設定（IP名ごと）</h2>
      <div class="grid grid-3">
        <div class="mini">direction: auto/left/right/none、R>0 のとき曲線として扱います</div>
        <div><button class="btn" id="addCurve">+ 曲線追加</button></div>
        <div class="mini">A指定：L=A²/R（A1/A2） / L指定：Lsを使用</div>
      </div>

      <div style="overflow:auto; margin-top:10px;">
        <table>
          <thead>
            <tr><th>対象IP</th><th>direction</th><th>R</th><th>A1</th><th>A2</th><th>Ls</th><th class="right">削除</th></tr>
          </thead>
          <tbody>
            ${state.curveSettings.map(c=>`
              <tr>
                <td>
                  <select data-c-ip="${c.id}">
                    ${state.ipPoints.map(p=>`<option value="${p.name}" ${p.name===c.ipName?"selected":""}>${p.name}</option>`).join("")}
                  </select>
                </td>
                <td>
                  <select data-c-dir="${c.id}">
                    ${["auto","left","right","none"].map(d=>`<option value="${d}" ${d===c.direction?"selected":""}>${d}</option>`).join("")}
                  </select>
                </td>
                <td><input data-c-r="${c.id}" type="number" step="0.001" value="${c.R}" /></td>
                <td><input data-c-a1="${c.id}" type="number" step="0.001" value="${c.A1 ?? 0}" /></td>
                <td><input data-c-a2="${c.id}" type="number" step="0.001" value="${c.A2 ?? (c.A1 ?? 0)}" /></td>
                <td><input data-c-ls="${c.id}" type="number" step="0.001" value="${c.Ls ?? 0}" /></td>
                <td class="right"><button class="btn btn-ghost" data-c-del="${c.id}">削除</button></td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>サマリ</h2>
      <div class="grid grid-3">
        <div><b>総延長</b>：<span class="kpi">${res.total.toFixed(3)} m</span></div>
        <div class="pill">警告 ${res.warnings.length} 件</div>
        <div class="pill">IP数 ${state.ipPoints.length}（使用 ${state.useIpCount}）</div>
      </div>
      ${res.warnings.map(w=>`<div class="warn">⚠ ${w}</div>`).join("")}
    </div>

    <div class="card">
      <h2>平面線形：簡易図（左/右が分かる）</h2>
      <div class="grid grid-3">
        <div>
          <label>図のサンプル間隔 ds(m)</label>
          <input id="plotStep" type="number" step="0.1" min="0.1" />
          <div class="mini">小さいほど滑らか（重くなる）</div>
        </div>
        <div>
          <label>表示</label>
          <div class="grid grid-2">
            <div><label class="mini"><input id="showKeypoints" type="checkbox" /> 主要点（TS/SC/CS/ST）</label></div>
            <div><label class="mini"><input id="showArrow" type="checkbox" /> 進行方向矢印</label></div>
          </div>
        </div>
        <div class="mini">凡例：直線/曲線（左）/曲線（右）</div>
      </div>

      <div class="canvasWrap" style="margin-top:10px;">
        <canvas id="planCanvas" width="980" height="520"></canvas>
      </div>
      <div class="mini" style="margin-top:8px;">※iPadの回転/画面幅によっては横スクロールで見てね</div>
    </div>

    <div class="card">
      <h2>平面：追加測点（出力に統合）</h2>
      <div class="grid grid-3">
        <div class="mini">
          入力：追加距離(m) / k+rem（pitch=${pitch}m）<br/>
          区切り：空白・カンマ・改行
        </div>
        <div>
          <label>追加測点 追加入力</label>
          <textarea id="extraTokens_plan" placeholder="例：101.527 / 5+1.527 / 0+50.000 など"></textarea>
        </div>
        <div>
          <button class="btn" id="addExtras_plan">＋ 追加</button>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="clearExtras_plan">平面追加を全クリア</button>
        </div>
      </div>

      ${state.extraStations.plan.length ? `
      <div style="overflow:auto; margin-top:10px;">
        <table>
          <thead><tr><th>ID</th><th>測点表示</th><th>追加距離(m)</th><th class="right">削除</th></tr></thead>
          <tbody>
            ${state.extraStations.plan.map(x=>`
              <tr>
                <td>${x.id}</td>
                <td>${metersToStaPitch(x.m, pitch, 3)}</td>
                <td><input data-ex-group="plan" data-ex-id="${x.id}" type="number" step="0.001" value="${x.m}" /></td>
                <td class="right"><button class="btn btn-ghost" data-ex-group="plan" data-ex-del="${x.id}">削除</button></td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>` : `<div class="mini" style="margin-top:10px;">（まだ平面の追加測点はありません）</div>`}
    </div>
  `;

  /* header bind */
  document.getElementById("projectName").oninput = (e)=>{ state.projectName = e.target.value; saveState(); render(); };
  document.getElementById("coordDecimals").onchange = (e)=>{ state.coordDecimals = parseInt(e.target.value,10)||3; saveState(); render(); };
  document.getElementById("staPitch").oninput = (e)=>{ state.staPitch = Math.max(1, parseInt(e.target.value,10)||20); saveState(); render(); };
  document.getElementById("outputStep").oninput = (e)=>{ state.outputStep = Math.max(1, parseInt(e.target.value,10)||20); saveState(); render(); };
  document.getElementById("dsSpiral").oninput = (e)=>{ state.dsSpiral = Math.max(0.001, parseFloat(e.target.value)||0.5); saveState(); render(); };
  document.getElementById("clothoidMode").onchange = (e)=>{ state.clothoidMode = e.target.value; saveState(); render(); };

  /* BP/EP bind */
  document.getElementById("bpN").value = state.bp.N;
  document.getElementById("bpE").value = state.bp.E;
  document.getElementById("epN").value = state.ep.N;
  document.getElementById("epE").value = state.ep.E;
  document.getElementById("bpN").oninput = (e)=>{ state.bp.N = parseFloat(e.target.value)||0; saveState(); render(); };
  document.getElementById("bpE").oninput = (e)=>{ state.bp.E = parseFloat(e.target.value)||0; saveState(); render(); };
  document.getElementById("epN").oninput = (e)=>{ state.ep.N = parseFloat(e.target.value)||0; saveState(); render(); };
  document.getElementById("epE").oninput = (e)=>{ state.ep.E = parseFloat(e.target.value)||0; saveState(); render(); };

  const useIp = document.getElementById("useIpCount");
  useIp.value = Math.max(0, Math.min(state.useIpCount, state.ipPoints.length));
  document.getElementById("useIpLabel").textContent = `${useIp.value} / ${state.ipPoints.length}`;
  useIp.oninput = (e)=>{ state.useIpCount = parseInt(e.target.value,10)||0; saveState(); render(); };

  document.getElementById("addIP").onclick = ()=>{
    const newId = Math.max(0, ...state.ipPoints.map(p=>p.id)) + 1;
    state.ipPoints.push({ id:newId, name:`IP${newId}`, N:0, E:0 });
    state.useIpCount = Math.min(state.ipPoints.length, state.useIpCount + 1);
    saveState(); render();
  };

  document.getElementById("resetDemo").onclick = ()=>{
    state.projectName="テスト案件";
    state.coordDecimals=3;
    state.staPitch=20;
    state.outputStep=20;
    state.dsSpiral=0.5;
    state.clothoidMode="A";
    state.bp={name:"BP",N:0,E:0};
    state.ep={name:"EP",N:0,E:500};
    state.ipPoints=[
      { id: 1, name:"IP1", N:0, E:0 },
      { id: 2, name:"IP2", N:0, E:200 },
      { id: 3, name:"IP3", N:150, E:350 },
    ];
    state.useIpCount=3;
    state.curveSettings=[{ id:1, ipName:"IP2", R:200, A1:100, A2:100, Ls:40, direction:"auto" }];
    state.extraStations=[];
    state.nextExtraId=1;

    state.profile.startSta = 0.0;
    state.profile.startZ = 0.0;
    state.profile.rows = [
      { id: 1, nextSta: 100.000, gradePct: 2.000, vcL: 60.000, vcYmax: null },
      { id: 2, nextSta: 300.000, gradePct: -1.000, vcL: null,  vcYmax: 0.100 },
      { id: 3, nextSta: 500.000, gradePct: 0.500, vcL: null, vcYmax: null },
    ];
    state.profile.nextRowId = 4;

    saveState(); render();
  };

  document.getElementById("delIP").onclick = ()=>{
    const sel = document.getElementById("delIpSel").value;
    if (!sel) return;
    const id = parseInt(sel,10);
    const delName = state.ipPoints.find(p=>p.id===id)?.name;
    state.ipPoints = state.ipPoints.filter(p=>p.id!==id);
    state.useIpCount = Math.min(state.useIpCount, state.ipPoints.length);
    const names = new Set(state.ipPoints.map(p=>p.name));
    state.curveSettings = state.curveSettings.filter(c=>names.has(c.ipName));
    if (delName) state.curveSettings = state.curveSettings.filter(c=>c.ipName!==delName);
    saveState(); render();
  };

  viewPlan.querySelectorAll("input[data-ip-name]").forEach(inp=>{
    const id = parseInt(inp.getAttribute("data-ip-name"),10);
    inp.oninput = (e)=>{
      const p = state.ipPoints.find(x=>x.id===id);
      if (p) p.name = e.target.value || p.name;
      saveState(); render();
    };
  });
  viewPlan.querySelectorAll("input[data-ip-n]").forEach(inp=>{
    const id = parseInt(inp.getAttribute("data-ip-n"),10);
    inp.oninput = (e)=>{
      const p = state.ipPoints.find(x=>x.id===id);
      if (p) p.N = parseFloat(e.target.value)||0;
      saveState(); render();
    };
  });
  viewPlan.querySelectorAll("input[data-ip-e]").forEach(inp=>{
    const id = parseInt(inp.getAttribute("data-ip-e"),10);
    inp.oninput = (e)=>{
      const p = state.ipPoints.find(x=>x.id===id);
      if (p) p.E = parseFloat(e.target.value)||0;
      saveState(); render();
    };
  });

  document.getElementById("addCurve").onclick = ()=>{
    if (!state.ipPoints.length) return;
    const newId = Math.max(0, ...state.curveSettings.map(c=>c.id)) + 1;
    const defaultIP = state.ipPoints[Math.min(1, state.ipPoints.length-1)]?.name || state.ipPoints[0].name;
    state.curveSettings.push({ id:newId, ipName:defaultIP, R:200, A1:100, A2:100, Ls:40, direction:"auto" });
    saveState(); render();
  };

  viewPlan.querySelectorAll("select[data-c-ip]").forEach(sel=>{
    const id = parseInt(sel.getAttribute("data-c-ip"),10);
    sel.onchange = (e)=>{
      const c = state.curveSettings.find(x=>x.id===id);
      if (c) c.ipName = e.target.value;
      saveState(); render();
    };
  });
  viewPlan.querySelectorAll("select[data-c-dir]").forEach(sel=>{
    const id = parseInt(sel.getAttribute("data-c-dir"),10);
    sel.onchange = (e)=>{
      const c = state.curveSettings.find(x=>x.id===id);
      if (c) c.direction = e.target.value;
      saveState(); render();
    };
  });

  const bindNum = (attr, key)=>{
    viewPlan.querySelectorAll(`input[${attr}]`).forEach(inp=>{
      const id = parseInt(inp.getAttribute(attr),10);
      inp.oninput = (e)=>{
        const c = state.curveSettings.find(x=>x.id===id);
        if (c) c[key] = parseFloat(e.target.value)||0;
        saveState(); render();
      };
    });
  };
  bindNum("data-c-r","R");
  bindNum("data-c-a1","A1");
  bindNum("data-c-a2","A2");
  bindNum("data-c-ls","Ls");

  viewPlan.querySelectorAll("button[data-c-del]").forEach(btn=>{
    const id = parseInt(btn.getAttribute("data-c-del"),10);
    btn.onclick = ()=>{
      state.curveSettings = state.curveSettings.filter(c=>c.id!==id);
      saveState(); render();
    };
  });

  document.getElementById("plotStep").value = state.plotStep;
  document.getElementById("showKeypoints").checked = !!state.showKeypoints;
  document.getElementById("showArrow").checked = !!state.showArrow;
  document.getElementById("plotStep").oninput = (e)=>{ state.plotStep = Math.max(0.1, parseFloat(e.target.value)||5); saveState(); render(); };
  document.getElementById("showKeypoints").onchange = (e)=>{ state.showKeypoints = !!e.target.checked; saveState(); render(); };
  document.getElementById("showArrow").onchange = (e)=>{ state.showArrow = !!e.target.checked; saveState(); render(); };

  const canvas = document.getElementById("planCanvas");
  drawPlanCanvas(canvas, res.segments, workPoints, res.keypoints, {
    plotStep: state.plotStep,
    showKeypoints: state.showKeypoints,
    showArrow: state.showArrow
  });


/* -------- PROFILE -------- */
const prof = state.profile || {enabled:false, startSta:0, startZ:0, grades:[], nextGradeId:1, vcurves:[], nextVcurveId:1};
const profModel = buildProfileModel(prof, res.total);
const pvInternal = (profModel.pv || []).slice(1, -1);
const pvKeys = new Set(pvInternal.map(p=>p.sta.toFixed(3)));
const vpiToA = new Map();
if (profModel.ok) {
  for (let i=1;i<profModel.pv.length-1;i++) {
    const key = profModel.pv[i].sta.toFixed(3);
    const prev = profModel.segments[i-1];
    const next = profModel.segments[i];
    const A = (next?.gDec ?? 0) - (prev?.gDec ?? 0);
    vpiToA.set(key, A);
  }
}

viewProfile.innerHTML = `
  <div class="card" id="secProfile">
    <h2>縦断線形（勾配区間 + 縦断曲線：VPI単位）</h2>

    <div class="grid grid-4">
      <div>
        <label class="mini"><input id="profEnabled" type="checkbox" /> 縦断を使う（GL出力）</label>
        <div class="mini">勾配%：小数3桁（例 2.534%） / ymax：小数3桁（例 0.145m）</div>
      </div>
      <div>
        <button class="btn" id="addGradeRow">＋ 勾配区間追加</button>
        <div style="height:10px;"></div>
        <button class="btn btn-ghost" id="sortGradeRow">測点で整列</button>
      </div>
      <div>
        <button class="btn btn-ok" id="setEndToTotal">終点を平面総延長にセット</button>
        <div class="mini" style="margin-top:8px;">最後の勾配区間の nextSta を ${res.total.toFixed(3)}m にします</div>
      </div>
      <div class="mini">
        <b>平面総延長</b>：${res.total.toFixed(3)} m<br/>
        <b>PV点</b>：${profModel.pv.length} / <b>曲線</b>：${profModel.curves.length}<br/>
        <span class="pill">警告 ${profModel.warnings.length} 件</span>
      </div>
    </div>

    <div class="sep"></div>

    <div class="grid grid-3">
      <div><label>勾配起点 測点(m)</label><input id="startSta" type="number" step="0.001" value="${Number(prof.startSta||0).toFixed(3)}"/></div>
      <div><label>勾配起点 標高(m)</label><input id="startZ" type="number" step="0.001" value="${Number(prof.startZ||0).toFixed(3)}"/></div>
      <div class="mini">
        参考：測点表示（pitch=${pitch}m）: ${metersToStaPitch(res.total, pitch, 3)}
      </div>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>次の測点(m)</th>
            <th>勾配(%)</th>
            <th class="right">削除</th>
          </tr>
        </thead>
        <tbody>
          ${(prof.grades||[]).map(r=>`
            <tr>
              <td><input data-g-nextsta="${r.id}" type="number" step="0.001" value="${Number(r.nextSta??0).toFixed(3)}"/></td>
              <td><input data-g-grade="${r.id}" type="number" step="0.001" value="${Number(r.gradePct??0).toFixed(3)}"/></td>
              <td class="right"><button class="btn btn-ghost" data-g-del="${r.id}">削除</button></td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    </div>

    ${profModel.warnings.map(w=>`<div class="warn">⚠ ${w}</div>`).join("")}
  </div>

  <div class="card">
    <h2>縦断曲線（VPI単位で管理）</h2>
    <div class="grid grid-3">
      <div class="mini">
        VPIは「PV点（勾配の折点）」から選択。<br/>
        <b>L優先</b>。Lが空のときは ymax から <b>L=8*ymax/|A|</b> で換算（A=勾配差）。
      </div>
      <div>
        <button class="btn" id="addVcurve">＋ 縦断曲線追加</button>
        <div style="height:10px;"></div>
        <button class="btn btn-ghost" id="sortVcurve">VPIで整列</button>
      </div>
      <div class="mini">
        PV候補：${pvInternal.length} 点（内部PVのみ）
      </div>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>VPI</th>
            <th>Δg(%)</th>
            <th>曲線長 L(m)</th>
            <th>ymax(m)</th>
            <th class="right">削除</th>
          </tr>
        </thead>
        <tbody>
          ${(prof.vcurves||[]).map(r=>{
            const k = (Number(r.vpiSta)||0).toFixed(3);
            const A = (vpiToA.get(k) ?? 0) * 100;
            const extraOpt = pvKeys.has(k) ? "" : `<option value="${k}" selected>（PVに無い） ${k}m</option>`;
            const opts = pvInternal.map(p=>{
              const v = p.sta.toFixed(3);
              const sel = (v===k) ? "selected" : "";
              return `<option value="${v}" ${sel}>${metersToStaPitch(p.sta, pitch, 3)} (${v}m)</option>`;
            }).join("");
            return `
              <tr>
                <td>
                  <select data-vc-vpi="${r.id}">
                    ${extraOpt}
                    ${opts}
                  </select>
                </td>
                <td>${A.toFixed(3)}</td>
                <td><input data-vc-l="${r.id}" type="number" step="0.001" value="${(r.L==null||r.L==="")?"":Number(r.L).toFixed(3)}" placeholder="例 80.000"/></td>
                <td><input data-vc-y="${r.id}" type="number" step="0.001" value="${(r.ymax==null||r.ymax==="")?"":Number(r.ymax).toFixed(3)}" placeholder="例 0.145"/></td>
                <td class="right"><button class="btn btn-ghost" data-vc-del="${r.id}">削除</button></td>
              </tr>
            `;
          }).join("")}
        </tbody>
      </table>
    </div>
    <div class="mini" style="margin-top:8px;">※縦断曲線は対称（BVC=VPI-L/2, EVC=VPI+L/2）</div>
  </div>

  <div class="card">
    <h2>縦断：追加測点（出力に統合）</h2>
    <div class="grid grid-3">
      <div class="mini">
        入力：追加距離(m) / k+rem（pitch=${pitch}m）<br/>
        区切り：空白・カンマ・改行
      </div>
      <div>
        <label>追加測点 追加入力</label>
        <textarea id="extraTokens_profile" placeholder="例：101.527 / 5+1.527 / 0+50.000 など"></textarea>
      </div>
      <div>
        <button class="btn" id="addExtras_profile">＋ 追加</button>
        <div style="height:10px;"></div>
        <button class="btn btn-ghost" id="clearExtras_profile">縦断追加を全クリア</button>
      </div>
    </div>

    ${state.extraStations.profile.length ? `
    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead><tr><th>ID</th><th>測点表示</th><th>追加距離(m)</th><th class="right">削除</th></tr></thead>
        <tbody>
          ${state.extraStations.profile.map(x=>`
            <tr>
              <td>${x.id}</td>
              <td>${metersToStaPitch(x.m, pitch, 3)}</td>
              <td><input data-ex-group="profile" data-ex-id="${x.id}" type="number" step="0.001" value="${x.m}" /></td>
              <td class="right"><button class="btn btn-ghost" data-ex-group="profile" data-ex-del="${x.id}">削除</button></td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    </div>` : `<div class="mini" style="margin-top:10px;">（まだ縦断の追加測点はありません）</div>`}
  </div>
`;

document.getElementById("profEnabled").checked = !!prof.enabled;
document.getElementById("profEnabled").onchange = (e)=>{ state.profile.enabled = !!e.target.checked; saveState(); render(); };
document.getElementById("startSta").onchange = (e)=>{ state.profile.startSta = parseFloat(e.target.value)||0; saveState(); render(); };
document.getElementById("startZ").onchange   = (e)=>{ state.profile.startZ = parseFloat(e.target.value)||0; saveState(); render(); };

document.getElementById("addGradeRow").onclick = ()=>{
  state.profile.grades.push({ id: state.profile.nextGradeId++, nextSta: 0.000, gradePct: 0.000 });
  saveState(); render();
};
document.getElementById("sortGradeRow").onclick = ()=>{
  state.profile.grades.sort((a,b)=> (Number(a.nextSta)||0) - (Number(b.nextSta)||0));
  saveState(); render();
};
document.getElementById("setEndToTotal").onclick = ()=>{
  const total = Number(res.total||0);
  if (!state.profile.grades.length) {
    state.profile.grades.push({ id: state.profile.nextGradeId++, nextSta: total, gradePct: 0.000 });
  } else {
    let idx = 0;
    for (let i=1;i<state.profile.grades.length;i++){
      if ((Number(state.profile.grades[i].nextSta)||0) >= (Number(state.profile.grades[idx].nextSta)||0)) idx = i;
    }
    state.profile.grades[idx].nextSta = Number(total.toFixed(3));
  }
  state.profile.grades.sort((a,b)=> (Number(a.nextSta)||0) - (Number(b.nextSta)||0));
  saveState(); render();
};

viewProfile.querySelectorAll("input[data-g-nextsta]").forEach(inp=>{
  const id = parseInt(inp.getAttribute("data-g-nextsta"),10);
  inp.onchange = (e)=>{
    const r = state.profile.grades.find(x=>x.id===id);
    if (r) r.nextSta = parseFloat(e.target.value)||0;
    saveState(); render();
  };
});
viewProfile.querySelectorAll("input[data-g-grade]").forEach(inp=>{
  const id = parseInt(inp.getAttribute("data-g-grade"),10);
  inp.onchange = (e)=>{
    const r = state.profile.grades.find(x=>x.id===id);
    if (r) r.gradePct = parseFloat(e.target.value)||0;
    saveState(); render();
  };
});
viewProfile.querySelectorAll("button[data-g-del]").forEach(btn=>{
  const id = parseInt(btn.getAttribute("data-g-del"),10);
  btn.onclick = ()=>{
    state.profile.grades = state.profile.grades.filter(x=>x.id!==id);
    saveState(); render();
  };
});

const addVcurveBtn = document.getElementById("addVcurve");
if (addVcurveBtn) {
  addVcurveBtn.onclick = ()=>{
    if (!pvInternal.length) {
      alert("PV点がありません。先に勾配区間を入れてください");
      return;
    }
    // なるべく未使用のPVを選ぶ
    const used = new Set((state.profile.vcurves||[]).map(x=>(Number(x.vpiSta)||0).toFixed(3)));
    const pick = pvInternal.find(p=>!used.has(p.sta.toFixed(3))) || pvInternal[0];
    state.profile.vcurves.push({ id: state.profile.nextVcurveId++, vpiSta: Number(pick.sta.toFixed(3)), L: null, ymax: null });
    saveState(); render();
  };
}
const sortVcurveBtn = document.getElementById("sortVcurve");
if (sortVcurveBtn) {
  sortVcurveBtn.onclick = ()=>{
    state.profile.vcurves.sort((a,b)=> (Number(a.vpiSta)||0) - (Number(b.vpiSta)||0));
    saveState(); render();
  };
}

viewProfile.querySelectorAll("select[data-vc-vpi]").forEach(sel=>{
  const id = parseInt(sel.getAttribute("data-vc-vpi"),10);
  sel.onchange = (e)=>{
    const r = state.profile.vcurves.find(x=>x.id===id);
    if (r) r.vpiSta = parseFloat(e.target.value)||0;
    saveState(); render();
  };
});
viewProfile.querySelectorAll("input[data-vc-l]").forEach(inp=>{
  const id = parseInt(inp.getAttribute("data-vc-l"),10);
  inp.onchange = (e)=>{
    const r = state.profile.vcurves.find(x=>x.id===id);
    if (r) r.L = setOrNull(e.target.value);
    saveState(); render();
  };
});
viewProfile.querySelectorAll("input[data-vc-y]").forEach(inp=>{
  const id = parseInt(inp.getAttribute("data-vc-y"),10);
  inp.onchange = (e)=>{
    const r = state.profile.vcurves.find(x=>x.id===id);
    if (r) r.ymax = setOrNull(e.target.value);
    saveState(); render();
  };
});
viewProfile.querySelectorAll("button[data-vc-del]").forEach(btn=>{
  const id = parseInt(btn.getAttribute("data-vc-del"),10);
  btn.onclick = ()=>{
    state.profile.vcurves = state.profile.vcurves.filter(x=>x.id!==id);
    saveState(); render();
  };
});

bindExtraUI("profile", viewProfile, pitch);

/* -------- CROSS -------- */
  ensureCrossState();

  const cr = computeCrossSide("common", "right");
  const cl = computeCrossSide("common", "left");

  const selKey = state.cross.ui.selectedStaKey || "";
  const hasSel = !!(selKey && state.cross.overrides && state.cross.overrides[selKey]);
  const or = hasSel ? computeCrossSide("ovr", "right", selKey) : null;
  const ol = hasSel ? computeCrossSide("ovr", "left",  selKey) : null;

  const crossRowsHtml = (scope, side, staKey)=>{
    const store = getCrossStore(scope, side, staKey);
    const segs = store.segs || [];
    const staAttr = (scope === "ovr" && staKey) ? ` data-xs-sta="${staKey}"` : "";

    if (!segs.length) {
      return `<tr><td colspan="6" class="mini">（まだ区間がありません）</td></tr>`;
    }

    let start = 0;
    let z = 0;
    const out = [];

    for (const r of segs) {
      const end = Number(r.end);
      const slopePct = Number(r.slopePct)||0;
      const span = (Number.isFinite(end) ? (end - start) : NaN);
      const dz = Number.isFinite(span) ? (slopePct/100.0)*span : NaN;
      if (Number.isFinite(dz)) z += dz;

      out.push(`
        <tr>
          <td class="right">${start.toFixed(3)}</td>
          <td><input data-xs-scope="${scope}"${staAttr} data-xs-side="${side}" data-xs-id="${r.id}" data-xs-end type="number" step="0.001" value="${Number.isFinite(end)?end:0}" /></td>
          <td><input data-xs-scope="${scope}"${staAttr} data-xs-side="${side}" data-xs-id="${r.id}" data-xs-slope type="number" step="0.001" value="${slopePct}" /></td>
          <td class="right">${Number.isFinite(dz)?dz.toFixed(3):""}</td>
          <td class="right">${Number.isFinite(z)?z.toFixed(3):""}</td>
          <td class="right"><button class="btn btn-ghost" data-xs-scope="${scope}"${staAttr} data-xs-side="${side}" data-xs-del="${r.id}">削除</button></td>
        </tr>
      `);

      if (Number.isFinite(end)) start = end;
    }

    return out.join("");
  };

  const warnHtml = (arr)=> arr && arr.length ? `<div class="warn">${arr.join(" / ")}</div>` : "";

  const ovKeys = Object.keys(state.cross.overrides||{}).slice().sort((a,b)=> (Number(a)||0) - (Number(b)||0));
  const ovOptions = ovKeys.map(k=>{
    const m = Number(k);
    const label = Number.isFinite(m) ? `${metersToStaPitch(m, pitch, 3)} (${k}m)` : k;
    const sel = (k===selKey) ? "selected" : "";
    return `<option value="${k}" ${sel}>${label}</option>`;
  }).join("");

  viewCross.innerHTML = `
    <div class="card" id="secCross">
      <h2>横断：勾配区間（中心 → 外側）</h2>
      <div class="mini">中心から外側へ、任意距離で勾配変化点を作れます。距離は自動で昇順に整列されます。</div>

      <div class="row" style="margin-top:10px;">
        <div style="width:200px;">
          <label>全測点 最外端距離 右(+)(m)</label>
          <input id="bulkCrossEnd_right" type="number" step="0.001" min="0" value="${cr.lastEnd.toFixed(3)}" />
        </div>
        <div style="width:200px;">
          <label>全測点 最外端距離 左(-)(m)</label>
          <input id="bulkCrossEnd_left" type="number" step="0.001" min="0" value="${cl.lastEnd.toFixed(3)}" />
        </div>
        <div style="flex:1; min-width:200px;">
          <label>一括適用</label>
          <button class="btn" id="applyBulkCrossEnd">最外端を一括更新</button>
          <div class="mini" style="margin-top:6px;">
            <label class="mini"><input id="bulkAffectOverrides" type="checkbox" checked /> 測点別の例外にも適用</label>
          </div>
        </div>

      </div>

      <div class="row" style="margin-top:10px; align-items:flex-end;">
        <div style="width:180px;">
          <label>拡幅割付（線形）</label>
          <label class="mini"><input id="xsTaperEnabled" type="checkbox" ${state.cross.taper && state.cross.taper.enabled ? "checked" : ""} /> 有効</label>
        </div>
        <div style="width:200px;">
          <label>アンカー距離 右(+)(m)</label>
          <input id="xsAnchorRight" type="number" step="0.001" min="0" value="${Number(state.cross.taper?.anchorRight ?? 3.0).toFixed(3)}" />
        </div>
        <div style="width:200px;">
          <label>アンカー距離 左(-)(m)</label>
          <input id="xsAnchorLeft" type="number" step="0.001" min="0" value="${Number(state.cross.taper?.anchorLeft ?? 3.0).toFixed(3)}" />
        </div>
        <div style="flex:1; min-width:260px;">
          <div class="mini">例外測点の最外端距離を制御点として幅員を線形補間し、アンカーより外側の距離をシフトして割付します（左右独立）。</div>
        </div>
      </div>

      <div class="grid grid-2" style="margin-top:10px;">
        <div>
          <div class="pill">右側（+） 共通（全測点）</div>
          <div style="overflow:auto; margin-top:8px;">
            <table>
              <thead><tr><th class="right">開始(m)</th><th>終了(m)</th><th>勾配(%)</th><th class="right">ΔZ(m)</th><th class="right">Z累積(m)</th><th class="right">操作</th></tr></thead>
              <tbody>${crossRowsHtml("common", "right")}</tbody>
            </table>
          </div>
          <div class="row">
            <div style="flex:1; min-width:160px;"><button class="btn" id="addCrossSeg_right">＋ 右側区間を追加</button></div>
            <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="exampleCrossSeg_right">例を入れる</button></div>
            <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="clearCrossSeg_right">右側を全クリア</button></div>
          </div>
          <div class="mini">最外端：+${cr.lastEnd.toFixed(3)} m / Z=${cr.lastZ.toFixed(3)} m</div>
          ${warnHtml(cr.warnings)}
        </div>

        <div>
          <div class="pill">左側（-） 共通（全測点）</div>
          <div style="overflow:auto; margin-top:8px;">
            <table>
              <thead><tr><th class="right">開始(m)</th><th>終了(m)</th><th>勾配(%)</th><th class="right">ΔZ(m)</th><th class="right">Z累積(m)</th><th class="right">操作</th></tr></thead>
              <tbody>${crossRowsHtml("common", "left")}</tbody>
            </table>
          </div>
          <div class="row">
            <div style="flex:1; min-width:160px;"><button class="btn" id="addCrossSeg_left">＋ 左側区間を追加</button></div>
            <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="exampleCrossSeg_left">例を入れる</button></div>
            <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="clearCrossSeg_left">左側を全クリア</button></div>
          </div>
          <div class="mini">最外端：-${cl.lastEnd.toFixed(3)} m / Z=${cl.lastZ.toFixed(3)} m</div>
          ${warnHtml(cl.warnings)}
        </div>
      </div>

      <div class="sep"></div>
      <div class="mini">例：中心→3.000m -2.000% / 3.000→4.500m 0.000% / 4.500→5.000m -1.000%</div>

      <div class="sep"></div>
      <h2 style="margin-top:0;">横断：測点別（例外設定）</h2>
      <div class="mini">通常は「共通（全測点）」が適用されます。勾配変化点が必要な測点だけ、例外を作って編集できます。</div>

      <div class="grid grid-3" style="margin-top:10px;">
        <div>
          <label>対象測点（m / k+rem）</label>
          <input id="xsOverrideSta" type="text" placeholder="例：100.000 / 5+0.000" />
          <div class="mini">pitch=${pitch}m</div>
        </div>
        <div>
          <label>既存の例外</label>
          <select id="xsOverrideSel">
            <option value="">（選択なし）</option>
            ${ovOptions}
          </select>
          <div class="mini">選択すると編集対象になります</div>
        </div>
        <div>
          <label>操作</label>
          <button class="btn" id="xsOverrideAddOrSelect">＋ 作成/選択</button>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="xsOverrideDelete" ${hasSel?"":"disabled"}>例外を削除（共通に戻す）</button>
        </div>
      </div>

      ${hasSel ? `
        <div class="row" style="margin-top:10px; align-items:flex-end;">
          <div style="width:220px;">
            <label>例外 最外端距離 右(+)(m)</label>
            <input id="ovrWidthRight" type="number" step="0.001" min="0" value="${or.lastEnd.toFixed(3)}" />
          </div>
          <div style="width:220px;">
            <label>例外 最外端距離 左(-)(m)</label>
            <input id="ovrWidthLeft" type="number" step="0.001" min="0" value="${ol.lastEnd.toFixed(3)}" />
          </div>
          <div style="flex:1; min-width:260px;">
            <label>幅員適用（共通形状→アンカー以外を自動シフト）</label>
            <button class="btn" id="applyOvrWidth">この例外に幅員を適用</button>
            <div class="mini" style="margin-top:6px;">※左右独立で適用。既存の例外形状を上書きします。</div>
          </div>
        </div>

        <div class="grid grid-2" style="margin-top:10px;">
          <div>
            <div class="pill">右側（+） 例外 @ ${metersToStaPitch(Number(selKey), pitch, 3)} (${selKey}m)</div>
            <div style="overflow:auto; margin-top:8px;">
              <table>
                <thead><tr><th class="right">開始(m)</th><th>終了(m)</th><th>勾配(%)</th><th class="right">ΔZ(m)</th><th class="right">Z累積(m)</th><th class="right">操作</th></tr></thead>
                <tbody>${crossRowsHtml("ovr", "right", selKey)}</tbody>
              </table>
            </div>
            <div class="row">
              <div style="flex:1; min-width:160px;"><button class="btn" id="addCrossSeg_ovr_right">＋ 右側区間を追加</button></div>
              <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="exampleCrossSeg_ovr_right">例を入れる</button></div>
              <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="clearCrossSeg_ovr_right">右側を全クリア</button></div>
            </div>
            <div class="mini">最外端：+${or.lastEnd.toFixed(3)} m / Z=${or.lastZ.toFixed(3)} m</div>
            ${warnHtml(or.warnings)}
          </div>

          <div>
            <div class="pill">左側（-） 例外 @ ${metersToStaPitch(Number(selKey), pitch, 3)} (${selKey}m)</div>
            <div style="overflow:auto; margin-top:8px;">
              <table>
                <thead><tr><th class="right">開始(m)</th><th>終了(m)</th><th>勾配(%)</th><th class="right">ΔZ(m)</th><th class="right">Z累積(m)</th><th class="right">操作</th></tr></thead>
                <tbody>${crossRowsHtml("ovr", "left", selKey)}</tbody>
              </table>
            </div>
            <div class="row">
              <div style="flex:1; min-width:160px;"><button class="btn" id="addCrossSeg_ovr_left">＋ 左側区間を追加</button></div>
              <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="exampleCrossSeg_ovr_left">例を入れる</button></div>
              <div style="flex:1; min-width:160px;"><button class="btn btn-ghost" id="clearCrossSeg_ovr_left">左側を全クリア</button></div>
            </div>
            <div class="mini">最外端：-${ol.lastEnd.toFixed(3)} m / Z=${ol.lastZ.toFixed(3)} m</div>
            ${warnHtml(ol.warnings)}
          </div>
        </div>
      ` : `<div class="mini" style="margin-top:10px;">（例外は未選択です。必要な測点を作成/選択してください）</div>`}



      <div class="sep"></div>
      <h2 style="margin-top:0;">簡易横断図（プレビュー）</h2>
      <div class="mini">測点を指定すると、拡幅割付（テーパ）を反映した横断形状を表示します。</div>

      <div class="row" style="margin-top:10px; align-items:flex-end;">
        <div style="width:260px;">
          <label>プレビュー測点（m / k+rem）</label>
          <input id="xsPreviewSta" type="text" placeholder="例：110.000 / 1+10.000" value="${(state.cross.ui.previewTok||"")}" />
          <div class="mini">pitch=${pitch}m</div>
        </div>
        <div style="width:220px;">
          <label>操作</label>
          <button class="btn" id="xsPreviewShow">表示</button>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="xsPreviewUseSelected" ${hasSel?"":"disabled"}>選択中の例外を表示</button>
        </div>
        <div style="flex:1; min-width:260px;">
          <div class="mini" id="xsPreviewInfo"></div>
        </div>
      </div>

      <div style="overflow:auto; margin-top:10px;">
        <canvas id="xsCanvas" width="1000" height="260" style="width:100%; max-width:1000px; border:1px solid var(--line); border-radius:12px; background:#fff;"></canvas>
      </div>
      <div class="mini" id="xsPreviewTable" style="margin-top:10px;"></div>

    </div>

    <div class="card">
      <h2>横断（追加測点のみ）</h2>
      <div class="grid grid-3">
        <div class="mini">
          ここは「横断追加測点（中心線の測点）」の管理だけ。<br/>
          ここで追加した測点は最終CSVに統合します。
        </div>
        <div>
          <label>横断：追加測点 追加入力</label>
          <textarea id="extraTokens_cross" placeholder="例：101.527 / 5+1.527 / 0+50.000 など"></textarea>
        </div>
        <div>
          <button class="btn" id="addExtras_cross">＋ 追加</button>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="clearExtras_cross">横断追加を全クリア</button>
        </div>
      </div>

      ${state.extraStations.cross.length ? `
      <div style="overflow:auto; margin-top:10px;">
        <table>
          <thead><tr><th>ID</th><th>測点表示</th><th>追加距離(m)</th><th class="right">削除</th></tr></thead>
          <tbody>
            ${state.extraStations.cross.map(x=>`
              <tr>
                <td>${x.id}</td>
                <td>${metersToStaPitch(x.m, pitch, 3)}</td>
                <td><input data-ex-group="cross" data-ex-id="${x.id}" type="number" step="0.001" value="${x.m}" /></td>
                <td class="right"><button class="btn btn-ghost" data-ex-group="cross" data-ex-del="${x.id}">削除</button></td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>` : `<div class="mini" style="margin-top:10px;">（まだ横断の追加測点はありません）</div>`}
    </div>
  `;

  // 一括距離
  const bulkBtn = document.getElementById("applyBulkCrossEnd");
  if (bulkBtn) {
    bulkBtn.onclick = ()=>{
      const er = parseFloat(document.getElementById("bulkCrossEnd_right").value);
      const el = parseFloat(document.getElementById("bulkCrossEnd_left").value);
      const affect = !!document.getElementById("bulkAffectOverrides").checked;
      applyCrossOuterEnd(er, el, affect);
      saveState();
      render();
    };
  }

  // 例外：選択
  const selEl = document.getElementById("xsOverrideSel");
  if (selEl) {
    selEl.value = selKey;
    selEl.onchange = (e)=>{
      state.cross.ui.selectedStaKey = e.target.value || "";
      saveState();
      render();
    };
  }

  // 例外：作成/選択
  const addSelBtn = document.getElementById("xsOverrideAddOrSelect");
  if (addSelBtn) {
    addSelBtn.onclick = ()=>{
      const pitchNow = Math.max(1, Math.floor(state.staPitch||1));
      const sel = (document.getElementById("xsOverrideSel")?.value || "").trim();
      if (sel) {
        state.cross.ui.selectedStaKey = sel;
        saveState();
        render();
        return;
      }
      const tok = (document.getElementById("xsOverrideSta")?.value || "").trim();
      if (!tok) { alert("測点を入力してください"); return; }
      let m;
      try {
        m = parseTokenToM(tok, pitchNow);
      } catch(e) {
        alert("測点が不正です: " + (e.message||e));
        return;
      }
      const key = Number(m.toFixed(3));
      const k = key.toFixed(3);
      ensureCrossOverride(k);
      state.cross.ui.selectedStaKey = k;
      saveState();
      render();
    };
  }

  // 例外：削除
  const delBtn = document.getElementById("xsOverrideDelete");
  if (delBtn) {
    delBtn.onclick = ()=>{
      const k = state.cross.ui.selectedStaKey;
      if (!k) return;
      if (!confirm(`例外（${k}m）を削除して共通に戻します。よいですか？`)) return;
      delete state.cross.overrides[k];
      state.cross.ui.selectedStaKey = "";
      saveState();
      render();
    };
  }


  bindCrossSlopeUI(viewCross);

  // taper settings
  const cbTaper = document.getElementById('xsTaperEnabled');
  if (cbTaper) {
    cbTaper.onchange = ()=>{ ensureCrossState(); state.cross.taper.enabled = !!cbTaper.checked; saveState(); render(); };
  }
  const inAR = document.getElementById('xsAnchorRight');
  if (inAR) {
    inAR.oninput = (e)=>{ ensureCrossState(); state.cross.taper.anchorRight = parseFloat(e.target.value)||0; saveState(); };
  }
  const inAL = document.getElementById('xsAnchorLeft');
  if (inAL) {
    inAL.oninput = (e)=>{ ensureCrossState(); state.cross.taper.anchorLeft = parseFloat(e.target.value)||0; saveState(); };
  }

  // override width apply
  const btnApplyWidth = document.getElementById('applyOvrWidth');
  if (btnApplyWidth) {
    btnApplyWidth.onclick = ()=>{
      const k = state.cross.ui.selectedStaKey;
      if (!k) return;
      const wr = parseFloat(document.getElementById('ovrWidthRight')?.value);
      const wl = parseFloat(document.getElementById('ovrWidthLeft')?.value);
      if ((!Number.isFinite(wr) || wr<=0) && (!Number.isFinite(wl) || wl<=0)) { alert('幅員を入力してください'); return; }
      if (!confirm('共通形状から自動生成して、現在の例外形状を上書きします。よいですか？')) return;
      setOverrideWidthFromCommon(k, wr, wl);
      saveState();
      render();
    };
  }

  // preview
  const drawPreview = (tok)=>{
    const infoEl = document.getElementById('xsPreviewInfo');
    const tblEl = document.getElementById('xsPreviewTable');
    const canvas = document.getElementById('xsCanvas');
    if (!canvas) return;

    const pitchNow = Math.max(1, Math.floor(state.staPitch||1));
    let m;
    try {
      m = parseTokenToM(String(tok||'').trim(), pitchNow);
    } catch(e) {
      if (infoEl) infoEl.textContent = '測点が不正です: ' + (e.message||e);
      return;
    }
    m = clamp(m, 0, res.total||0);

    const R = getEffectiveCrossSegsAt(m, 'right');
    const L = getEffectiveCrossSegsAt(m, 'left');

    const rCalc = computeCrossRowsFromSegs(R.segs);
    const lCalc = computeCrossRowsFromSegs(L.segs);

    const ptsR = [{x:0,z:0}];
    for (const row of rCalc.rows) ptsR.push({x: row.end, z: row.zEnd});
    const ptsL = [{x:0,z:0}];
    for (const row of lCalc.rows) ptsL.push({x: -row.end, z: row.zEnd});

    const poly = [...ptsL.slice(1).reverse(), {x:0,z:0}, ...ptsR.slice(1)];

    const labels = [
      { x: -lCalc.lastEnd, z: lCalc.lastZ, text: `L=${lCalc.lastEnd.toFixed(3)}m` },
      { x:  rCalc.lastEnd, z: rCalc.lastZ, text: `R=${rCalc.lastEnd.toFixed(3)}m` },
    ];

    drawCrossPreviewCanvas(canvas, poly, labels);

    if (infoEl) {
      const sLabel = metersToStaPitch(m, pitchNow, 3);
      const modeR = `${R.info.source}:${R.info.mode}`;
      const modeL = `${L.info.source}:${L.info.mode}`;
      infoEl.textContent = `${sLabel} (${m.toFixed(3)}m)  右(+): ${rCalc.lastEnd.toFixed(3)}m [${modeR}] / 左(-): ${lCalc.lastEnd.toFixed(3)}m [${modeL}]`;
    }

    if (tblEl) {
      const mk = m.toFixed(3);
      const rowsToHtml = (calc, sideName)=>{
        const lines = calc.rows.map(r=>`${r.start.toFixed(3)}→${r.end.toFixed(3)} : ${r.slopePct.toFixed(3)}% (Z=${r.zEnd.toFixed(3)})`);
        return `<div style="margin-top:6px;"><b>${sideName}</b><br/>${lines.join('<br/>')}</div>`;
      };
      tblEl.innerHTML = rowsToHtml(lCalc,'左(-)') + rowsToHtml(rCalc,'右(+)');
    }
  };

  const inpPrev = document.getElementById('xsPreviewSta');
  const btnPrev = document.getElementById('xsPreviewShow');
  const btnUseSel = document.getElementById('xsPreviewUseSelected');

  const runPrev = ()=>{
    const tok = (inpPrev?.value||'').trim();
    ensureCrossState();
    state.cross.ui.previewTok = tok;
    saveState();
    drawPreview(tok);
  };

  if (btnPrev) btnPrev.onclick = runPrev;
  if (inpPrev) inpPrev.onchange = runPrev;

  if (btnUseSel) {
    btnUseSel.onclick = ()=>{
      const k = state.cross.ui.selectedStaKey;
      if (!k) return;
      if (inpPrev) inpPrev.value = k;
      runPrev();
    };
  }

  // 初期描画
  if (inpPrev && (!inpPrev.value || !inpPrev.value.trim())) {
    const k = state.cross.ui.selectedStaKey;
    inpPrev.value = k || '0.000';
    ensureCrossState();
    state.cross.ui.previewTok = inpPrev.value;
    saveState();
  }
  if (inpPrev) drawPreview(inpPrev.value);

  bindExtraUI("cross", viewCross, pitch);


  /* -------- OUTPUT -------- */
  const stepInt = Math.max(1, Math.floor(state.outputStep||1));
  ensureExtraState();

  const planKeyStas = (res.keypoints||[]).filter(k=>Number.isFinite(k.sta)).map(k=>k.sta);
  const profModelOut = buildProfileModel(state.profile, res.total);

  const pvStas = (profModelOut.ok ? (profModelOut.pv||[]).map(p=>p.sta) : []);
  const vcStas = [];
  if (profModelOut.ok) {
    for (const c of (profModelOut.curves||[])) {
      vcStas.push(c.s0, c.s0 + c.L/2, c.s1);
    }
  }

  const sources = [
    { label: "平面主要点", values: planKeyStas },
    ...(state.profile.enabled && profModelOut.ok ? [
      { label: "縦断PV", values: pvStas },
      { label: "縦断曲線(BVC/VPI/EVC)", values: vcStas },
    ] : []),
    { label: "平面追加", values: state.extraStations.plan.map(x=>x.m) },
    { label: "縦断追加", values: state.extraStations.profile.map(x=>x.m) },
    { label: "横断追加", values: state.extraStations.cross.map(x=>x.m) },
    { label: "統合追加", values: state.extraStations.output.map(x=>x.m) },
  ];

  const stBuild = buildUnifiedStationList(res.total, stepInt, sources);

  const breakdown = {
    planKey: planKeyStas.length,
    pv: pvStas.length,
    vc: vcStas.length,
    addPlan: state.extraStations.plan.length,
    addProf: state.extraStations.profile.length,
    addCross: state.extraStations.cross.length,
    addOut: state.extraStations.output.length,
  };

  viewOutput.innerHTML = `
    <div class="card" id="secOutput">
      <h2>最終出力（平面 + 縦断 + 横断の追加測点を統合して1本）</h2>
      <div class="grid grid-3">
        <div class="mini">
          <b>総延長</b>：${res.total.toFixed(3)} m<br/>
          <b>測点表示ピッチ</b>：${pitch} m / <b>出力間隔</b>：${stepInt} m<br/>
          <b>縦断GL出力</b>：${state.profile.enabled ? "ON" : "OFF"}
        </div>
        <div class="mini">
          <b>統合点数</b>：${stBuild.stations.length} 点<br/>
          <span class="pill">基準(0..総延長) ${stBuild.baseCount} 点</span>
          <span class="pill">追加(主要点+自由) ${stBuild.extraCount} 点</span>
        </div>
        <div class="mini">
          <b>内訳</b><br/>
          平面主要点 ${breakdown.planKey} / 縦断PV ${breakdown.pv} / 縦断曲線点 ${breakdown.vc}<br/>
          追加：平面 ${breakdown.addPlan} / 縦断 ${breakdown.addProf} / 横断 ${breakdown.addCross} / 統合 ${breakdown.addOut}
        </div>
      </div>
      ${stBuild.notes.map(n=>`<div class="warn">⚠ ${n}</div>`).join("")}
      <div class="mini" style="margin-top:8px;">※主要点（TS/SC/CS/ST）・PV・BVC/VPI/EVC は自動で含めます（重複は自動排除）</div>
    </div>

    <div class="card">
      <h2>統合追加測点（出力に統合）</h2>
      <div class="grid grid-3">
        <div class="mini">
          入力：追加距離(m) / k+rem（pitch=${pitch}m）<br/>
          区切り：空白・カンマ・改行
        </div>
        <div>
          <label>追加測点 追加入力</label>
          <textarea id="extraTokens_output" placeholder="例：101.527 / 5+1.527 / 0+50.000 など"></textarea>
        </div>
        <div>
          <button class="btn" id="addExtras_output">＋ 追加</button>
          <div style="height:10px;"></div>
          <button class="btn btn-ghost" id="clearExtras_output">統合追加を全クリア</button>
        </div>
      </div>

      ${state.extraStations.output.length ? `
      <div style="overflow:auto; margin-top:10px;">
        <table>
          <thead><tr><th>ID</th><th>測点表示</th><th>追加距離(m)</th><th class="right">削除</th></tr></thead>
          <tbody>
            ${state.extraStations.output.map(x=>`
              <tr>
                <td>${x.id}</td>
                <td>${metersToStaPitch(x.m, pitch, 3)}</td>
                <td><input data-ex-group="output" data-ex-id="${x.id}" type="number" step="0.001" value="${x.m}" /></td>
                <td class="right"><button class="btn btn-ghost" data-ex-group="output" data-ex-del="${x.id}">削除</button></td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>` : `<div class="mini" style="margin-top:10px;">（まだ統合追加測点はありません）</div>`}
    </div>

    <div class="card">
      <h2>中心線CSV出力</h2>
      <div class="grid grid-3">
        <div class="mini">
          出力点数：<b>${stBuild.stations.length}</b> 点<br/>
          座標小数桁：<b>${d}</b> 桁<br/>
          測点表示：<b>k+rem</b>（pitch=${pitch}m）
        </div>
        <div>
          <button class="btn btn-ok" id="dlCSV" ${stBuild.stations.length ? "" : "disabled"}>CSVダウンロード</button>
          <div class="mini" style="margin-top:8px;">ファイル名：${state.projectName}_中心線.csv</div>
        </div>
        <div class="mini">列：測点 / 追加距離 / N / E / Az / GL（縦断ON時）</div>
      </div>

      <div style="overflow:auto; max-height:420px; margin-top:10px;">
        <table>
          <thead><tr><th>測点</th><th>追加距離(m)</th><th>N</th><th>E</th><th>Az</th><th>GL</th></tr></thead>
          <tbody>
            ${stBuild.stations.slice(0,200).map(s=>{
              const p = evalAlignment(res.segments, s);
              const gl = state.profile.enabled ? evalProfileZ(profModelOut, s) : NaN;
              return `
                <tr>
                  <td>${metersToStaPitch(s, pitch, 3)}</td>
                  <td>${s.toFixed(3)}</td>
                  <td>${p.N.toFixed(d)}</td>
                  <td>${p.E.toFixed(d)}</td>
                  <td>${p.az.toFixed(4)}</td>
                  <td>${Number.isFinite(gl) ? gl.toFixed(3) : ""}</td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      </div>
      <div class="mini" style="margin-top:8px;">※プレビューは先頭200点まで</div>
    </div>
  `;

  bindExtraUI("output", viewOutput, pitch);

  const dlCSV = document.getElementById("dlCSV");
  if (dlCSV) {
    dlCSV.onclick = ()=> {
      const lines = [];
      lines.push(["STA","STA_M","N","E","AZ","GL"].join(","));
      for (const s of stBuild.stations) {
        const p = evalAlignment(res.segments, s);
        const gl = state.profile.enabled ? evalProfileZ(profModelOut, s) : NaN;
        lines.push([
          metersToStaPitch(s, pitch, 3),
          s.toFixed(3),
          p.N.toFixed(d),
          p.E.toFixed(d),
          p.az.toFixed(4),
          Number.isFinite(gl) ? gl.toFixed(3) : ""
        ].join(","));
      }
      downloadText(lines.join("\n"), `${state.projectName}_中心線.csv`, "text/csv;charset=utf-8");
    };
  }
  /* -------- SAVE -------- */
  viewSave.innerHTML = `
    <div class="card" id="secSave">
      <h2>保存（iPad内 自動保存 + JSON）</h2>
      <div class="grid grid-3">
        <div class="mini">
          <b>自動保存</b>：このiPadのlocalStorageに常時保存中。<br/>
          Safariのタブが落ちても復元しやすいです。<br/>
          ただし端末の整理で消える可能性はあるので、節目でJSON保存がおすすめ。
        </div>
        <div>
          <button class="btn btn-ok" id="saveJSON">JSONを書き出し（バックアップ）</button>
          <div style="height:10px;"></div>
          <input id="loadJSON" type="file" accept="application/json" />
        </div>
        <div>
          <button class="btn btn-ghost" id="clearLocal">iPad内保存を削除（注意）</button>
          <div class="mini" style="margin-top:8px;">※削除すると復元できません</div>
        </div>
      </div>
      <div class="mini" style="margin-top:10px;">
        更新が反映されないとき：<b>sw.js の CACHE_NAME を v7（例：road-align-v7）</b> に上げると確実です。
      </div>
    </div>
  `;

  /* save bind */
  const saveBtn = document.getElementById("saveJSON");
  if (saveBtn) {
    saveBtn.onclick = ()=>{
      const blob = JSON.stringify(state, null, 2);
      const name = `${state.projectName}_backup.json`;
      downloadText(blob, name, "application/json;charset=utf-8");
    };
  }
  const loadInput = document.getElementById("loadJSON");
  if (loadInput) {
    loadInput.onchange = async (e)=>{
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        const txt = await f.text();
        const obj = JSON.parse(txt);
        if (!obj || typeof obj !== "object") throw new Error("JSONが不正");
        state = normalizeState(Object.assign(state, obj));
        saveState();
        render();
        alert("読み込み完了");
      } catch(err) {
        alert("読み込み失敗: " + (err.message || err));
      } finally {
        e.target.value = "";
      }
    };
  }
  const clearLocalBtn = document.getElementById("clearLocal");
  if (clearLocalBtn) {
    clearLocalBtn.onclick = ()=>{
      if (!confirm("iPad内保存を削除します。よろしい？")) return;
      try { localStorage.removeItem(LS_KEY); } catch(e) {}
      alert("削除しました（次回起動は初期値）");
    };
  }

  saveState();
};

// Navigation buttons (jump to section)
document.querySelectorAll("[data-jump]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const id = btn.getAttribute("data-jump");
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior:"smooth", block:"start" });
  });
});

render();
</script>
</body>
</html>


